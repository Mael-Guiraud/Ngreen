\documentclass[a4paper,10pt]{article}
\usepackage[utf8]{inputenc}
\usepackage{xspace}
\usepackage{url}
\usepackage{graphicx,graphics} 
\usepackage{color}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{algorithm}
\usepackage{algorithmic}
\usepackage{longtable}
\usepackage{complexity}
\usepackage{tkz-graph}
\usepackage{float}
\usepackage{setspace}
\renewcommand{\algorithmicrequire}{\textbf{Input:}}
\renewcommand{\algorithmicensure}{\textbf{Output:}}

  
\graphicspath{{figures/}}
\newcommand\rmatching{${\cal R}$-matching\xspace}
\newcommand\mdelay{$\cal M$-delay\xspace}
\newcommand\matchedgraph{{\bf matched graph}}
\newtheorem{proposition}{Proposition}
\newtheorem{theorem}{Theorem}

\setlength{\parskip}{1ex} % Espace entre les paragraphes

\newtheorem{fact}{Fact}
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{definition}{Definition}
\newtheorem{corollary}{Corollary}



\newcommand{\todo}[1]{{\color{red} TODO: {#1}}}


%opening
\title{How to Schedule Periodic Messages in a Network Without Congestion}
%\author{Dominique Barth - UVSQ ,Christian Cadéré - UVSQ,Maël Guiraud - UVSQ,Olivier Marcé - Nokia Bell Labs France,Yann Strozecki - UVSQ}

\author{
   Dominique {\bf Barth}, {\em UVSQ}
   \and
   Christian  {\bf Cad\'er\'e}, {\em UVSQ}
      \and
   Ma\"el  {\bf Guiraud}, {\em UVSQ}
      \and
   Olivier  {\bf Marcr\'e}, {\em Nokia Bell Labs France}
      \and
   Yann  {\bf Strozecki}, {\em UVSQ}
} 

\begin{document}

\maketitle

\begin{abstract}
We study the sending of periodic messages in a graph following predefined paths, a problem arising from the communication between radio antennas and their signal processing units located in distant data-centers. The messages must be sent deterministically to avoid collisions on the network and thus to minimize the latency. We prove that the problem is $\NP$-complete even for very restricted graphs. We then deal with the case of a star graph and for different regimes of the parameters we propose algorithms that are experimentally shown to work extremely well
compared to traditional statistical multiplexing.
\end{abstract}


\section{Introduction}

Next generations of mobile network architectures evolve toward centralized radio network architectures or C-RAN, for Cloud Radio Access Network, to reduce energy consumption costs~\cite{mobile2011c}. The main challenge for this type of architecture is the latency in the transfer process between the Remote Radio Heads (RRHs) on the field and the Baseband Units (BBUs) in the cloud. The standard requires meeting time constraints for functions like HARQ (Hybrid Automatic Repeat reQuest) that needs to be processed in 1 to 10ms depending on targeted services~\cite{bouguen2012lte}. One specificity in the C-RAN context is not only the latency constraint, but also the periodicity of the data transfer between RRH and BBU.

 In this article, we study mechanisms to deal with the latency and periodicity constraints in the fronthaul network.  The current solution is to use statistical multiplexing with a traditional queue management in an optical network with a very large bandwidth to minimize latency. Here we propose to use a deterministic approach to schedule our periodic messages. This approach has gained some traction recently: Deterministic Networking is under standardization in IEEE 802.1 TSN group~\cite{finn-detnet-architecture-08}, as well at IETF DetNet working group~\cite{ieee802}. Several patents on concepts and mechanisms for DetNet have been already published, see for example~\cite{howe2005time,leclerc2016transmission}.

 
 The network topology is modeled by a directed weighted graph and a set of paths (routes) from source nodes (RRHs) to target nodes (BBUs). The time is discretized and a unit of time corresponds to the transmission of a minimal unit of data over the network.
 The process must be periodic, that is if we look at the network at time $t$ and $t+P$ where $P$ is the period, all messages are at the same position in the network. Moreover, we want to avoid any  buffering in internal nodes of the graph. Hence we need to design 
 a periodic process with no collision between messages. To ensure that this property is always true we propose a deterministic process.  We have two sets of parameters that we can choose when building a periodic sending process, called a \textbf{periodic assignment} in this article: the time at which each packet is sent by a RRH in each period and the waiting time in the BBU before the answer is sent back to the RRH. When building a periodic assignment, we must take into account the periodicity which makes many scheduling methods inapplicable. Not only a message must not collide with the other messages sent by the others BBU/RRH in the same period, but also in the previous and following periods. Moreover the latency must be minimized, that is the time 
 between the emission of a message and the complete return of its answer. It means that the only buffering we are allowed -- the waiting time before sending back the answer-- must be small, in particular when the route is long.
 
This problem may look like wormhole problems~\cite{cole1996benefit}, but here we want to minimize the time lost in buffers and not just avoid deadlocks, moreover the periodicity is not considered in wormhole problems. Several graph colorings have been introduced to model similar problems such as the allocation of frequencies~\cite{borndorfer1998frequency}, bandwidths~\cite{erlebach2001complexity} or routes~\cite{cole1996benefit} in a network or train schedules~\cite{strotmann2007railway}. Unfortunately, they do not take into account the periodicity and the associated problems are also $\NP$-complete. The only model which incorporates some periodicity is the circular coloring~\cite{zhou2013multiple, zhu2001circular,zhu2006recent} but is not expressive enough to capture our problem.


 In Sec.~\ref{sec:def} we propose a model of the network and the periodic sending of messages along its routes. 
 We then formalize our two problems of finding a periodic assignment for sending messages without collisions: PRA (sending of the message only) and PALL (sending of the message and answer).  
In Sec.~\ref{sec:complexity}, we prove that the problem PRA and PALL are $\NP$-hard and cannot be approximated even for very
restricted graphs. 
Therefore in the next two sections, we study a simple but very common topology, that we call the
star topology, on which the messages can collide on only one arc.
In Sec.\ref{sec:PAZL}, we study a variant of PALL called PAZL  where the waiting times must all be zero. We provide several algorithms, some of their theoretical properties and give experimental evidences that they find periodic assignments when the network is no too loaded. Finally in Sec.\ref{sec:PALL}, we propose algorithms for the general PALL problem and exhibit one which works extremely well in our experiments even in loaded networks. In particular we show that the deterministic communication schemes we design vastly outperform the traditional stochastic multiplexing with regards to latency. 


\section{Model and problems}\label{sec:def}

  \subsection{Network modeling}
  

The network is modeled as a directed graph $G=(V,A)$. Each arc  $(u,v)$ in $A$ is labeled by an integer $dl(u,v) \geq 1$ that we call the delay and which represents the time slots taken by a signal to go from $u$ to $v$ using this arc. A {\bf route} $r$ in $G$ is a path, that is sequence of consecutive arcs $a_0, \ldots , a_{k-1}$, with $a_i=(u_i,u_{i+1}) \in A$.  The {\bf latency} of a vertex $u_i$ in a path $r$, with $i \geq 1$, is defined by $\lambda(u_i,r)= \sum\limits_{0 \leq j <i} dl(a_j)$. We also define $\lambda(u_0,r)=0$. The latency of the route $r$ is defined by $\lambda (r)= \lambda (u_k,r)$.
We denote by $\cal R$ a set of routes in $G$ such that no two routes have the same first vertices or the same last vertices.
The pair $(G,\cal R)$ is called a {\bf routage graph} and represents our network.
The first vertex of a route models an antenna (RRH) and the last one a data-center (BBU) which processes the messages sent by the antenna. We denote by $\rho$ the bijection induced by ${\cal R}$, $\rho(s) = t$ if $s$ is the first vertex of a route $r$ and $t$ the last. 



   \subsection{Slotted time Model}
      
      Consider a route $r$ from $s$ to $t$. If we send a message at some point in time $m$ from $s$,
      then it will arrive at the vertex $v$ in $r$ at time $m + \lambda(v,r)$. Consider now a positive integer $P$ called the {\bf period}. In our problem, we send messages in the network with period $P$. The time will thus be cut into slices of $P$ discrete slots and we need to consider only one of such slices since they will all be identical. 
       Hence we define the first time slot at which a message sent from $s$ will reach a vertex $v$ in $r$ by $t(v,r) = m + \lambda(v,r) \mod P$. 
      
      A message usually cannot be transported in a single time slot. We denote by $\tau$ the number 
      of \emph{consecutive slots} necessary to transmit a message. Let us call $[t(v,r)]_{P,\tau}$ the set of time slots used by $r$ at a vertex $v$ in a period $P$, that is $[t(v,r)]_{P,\tau} = \{t(v,r) + k \mod P \mid 0 \leq k < \tau \}$. Usually $P$ and $\tau$ will be clear from the context and we will denote $[t(v,r)]_{P,\tau}$ by $[t(v,r)]$.
      
      
      A {\bf $(P,\tau)$-periodic assignment} of a routage graph $(G,\cal R)$ is a sequence  ${\cal M}=(m_1, \ldots ,m_n)$ of $n$ integers that we call {\bf offsets}, with $n$ the number of routes in $\cal R$. The number $m_{i}$ represents the time at which a message is emitted at the first vertex of the route $r_{i}$. We will always consider that the $m_{i}$ are between $O$ and $P-1$. A $(P,\tau)$-periodic assignment must have no {\bf collision} between two routes in $\cal R$, that is $\forall (r_{i}, r_{j}) \in {\cal R}^2, i \neq j$, % with $\tau$ the size (in number of consecutive slots) of each message that must be periodically sent on each route of ${\cal R}_{\cal C}$, 
      we have $$[t(u,r_{i})] \cap [t(u,r_{j})] = \emptyset .$$
      

%       Notice that the notion of $P$-periodic assignment \textbf{is not monotone} with regard to $P$. 
      As an example of a $(2,1)$-periodic assignment, let consider a routage graph with routes $\{r_{i}\}_{i=1,\dots,n}$, such that all pairs of routes intersect at a different edge.
      We set $\tau = 1$ and the delays are chosen so that if $r_{i}$ and $r_{j}$ have $v$ as first common vertex then we have $\lambda(v,r_{i}) - \lambda(v,r_{j})=1$.There is a $(2,1)$-periodic assignment by setting all $m_{i}$ to $0$.

%       A {\bf conflict graph} represents the collision between the routes of $ {\cal R}_{\cal C}$. The vertices of a conflict graph $G = (V,E)$ are the routes of $ {\cal R}_{\cal C}$, and there is an edge between two vertices if and only if there is a common arc between the two routes in $ {\cal R}_{\cal C}$.
%       
%       Given $u$ and $v$ two vertices of the conflict graph, corresponding to two routes colliding in $ {\cal R}_{\cal C}$. The weight of an edge, $w(u,v)$, is the absolute value of the difference between the distance of the two routes between their respective source node and the collision point.
%       
%       A labeling $F$ of such a graph is an assignment of an integer to each vertex, such that for each vertex $u$, $f(u) \neq f(v)+w(u,v)\mod P$, where $v$ are the neighbors of $u$ in the conflict graph and $P$ our period.
  
      \begin{figure}[ht]
      \begin{center}
          \scalebox{0.8}{
          
\begin{tikzpicture}


\tikzset{
  LabelStyle/.style = { rectangle, rounded corners, draw,
                       font = \bfseries },
  EdgeStyle/.append style = {->} }
  \SetGraphUnit{5}
  \node[draw,circle] (s3) at (4, 2) {$s_3$}; 
  \node[draw,circle] (s2) at (0, 4) {$s_2$}; 
  \node[draw,circle] (s1) at (0, 6) {$s_1$}; 

  \node[draw,circle] (t3) at (14, 7) {$t_3$}; 
  \node[draw,circle] (t2) at (14, 4) {$t_2$}; 
  \node[draw,circle] (t1) at (10, 2) {$t_1$}; 

  
  \SetVertexNoLabel
  \Vertex[x=2,y=5]{A}
  \Vertex[x=4,y=5]{B}
  \Vertex[x=10,y=5]{C}
  \Vertex[x=12,y=5]{D}
  \Vertex[x=6,y=3]{E}
  \Vertex[x=8,y=3]{F}
  \tikzset{
  EdgeStyle/.append style = {green} }
  \Edge[label = 2](s2)(A)
  \Edge[label = 1](A)(B)
  \Edge[label = 2](B)(C)
  \Edge[label = 1](C)(D)
  \Edge[label = 1](D)(t2)

  
   \tikzset{
  EdgeStyle/.append style = {red} }
  \Edge[label = 2](s3)(E)
  \Edge[label = 1](E)(F)
  \Edge[label = 1](F)(C)
  \Edge[label = 1](C)(D)
  \Edge[label = 1](D)(t3) 
     \tikzset{
  EdgeStyle/.append style = {blue} }
  \Edge[label = 1](s1)(A)
  \Edge[label = 1](A)(B)
  \Edge[label = 1](B)(E)
  \Edge[label = 1](E)(F)
  \Edge[label = 1](F)(t1)

\end{tikzpicture}

}
     \end{center}
       \caption{A routage graph with $(0,0,0)$ as a $(2,1)$-periodic assignment}
      \end{figure}


   \subsection{Problems}\label{nonmonotone}

    We want to find an assignment which allows to send periodic messages from sources to targets
    without collisions. We introduce the following associated decision problem, useful for hardness proofs.
    

      \noindent {\bf  Periodic Routes Assignment (PRA)} 

      \noindent {\bf Input:} a routage graph $(G,\cal R)$, an integer $\tau$ and an integer $P$.

      \noindent {\bf Question:} does there exist a $(P,\tau)$-periodic assignment of $(G,\cal R)$ ?


      We will prove in Sec.~\ref{sec:complexity} that the problem PRA is $\NP$-complete, even in restricted settings.
      Even approximating the smallest value of $P$ for which there is a $(P,\tau)$-periodic assignment is hard.
      
      An unusual property of assignment is that given a routage graph, we may have a $(P,\tau)$-periodic assignment but no
      $(P',\tau)$-periodic assignment with $P' > P$: the existence of an assignment is not monotone with regards to $P$.

	\begin{lemma} \label{lemma:monotonic}
	 For any odd $P$, there is a routage graph such that there is $(2,1)$-periodic assignment but no $(P,1)$-periodic assignment.
	\end{lemma}
\begin{proof}

      Consider the routage graph $(G,{\cal R})$ given in the previous subsection. 
      We change the delays so that for $v$, the first vertex which belongs to $r_i$ and $r_j$,
      we have $\lambda(v,r_i) - \lambda(v,r_j)= P$, where $P$ is an odd number smaller than $n$, the number of routes in ${\cal R_{\cal C}}$. In such a graph, there is no $(P,\tau)$-periodic assignment, since the problem reduces to finding a $P$-coloring in a complete graph with $n > P$ vertices.\\
      If we consider a period of $2$, for all $i \neq j$, $\lambda(v,r_i) - \lambda(v,r_j) \mod 2 = 1$ . Therefore $(0,\dots,0)$ is a $(2,1)$-periodic assignment of ${\cal R}$.

      
\end{proof}
      
% 
%       \begin{figure}[H]
%       \label{could-ran}
%       \begin{center}
%       % \begin{tabular}{cc}
%       \includegraphics[scale=0.5]{Total-latence.pdf}
%       \caption{Complete process for a leaf in $L$.}
%       \end{center}
%       \end{figure}
%       %\end{tabular}\newline

      
      In the context of cloud-RAN applications, we need to send message from a RRH $s$ to a BBUs $\rho(s)$ and then 
      we must send the answer from $\rho(s)$ back to $s$. We say that a routage graph $(G, {\cal R})$ is \textbf{symmetric}
      if for all route $r$ with first vertex $s$ and last vertex $target(s)$ there is a route $r'$ with first vertex $target(s)$
      and last vertex $s$. In all practical cases the routes $r$ and $r'$ will be the same with the orientation of the arcs reversed, which corresponds to bidirectional links in the networks, but we will not enforce this property.
      If the first vertex of $r$ is $s$, we will denote by $\rho(r)$ the route whose first vertex is $\rho(s)$.
         
         We now give a new interpretation of a $(P,\tau)$-periodic assignment of a $(G,{\cal R})$ symmetric routing graph, so that it represents the sending of a message and of its answer.
	This assignment represents the following process: first a message is sent at $s$, through the route $r$, at time $m$.
      
%       
%       We denote by $n$ the size of $S$ and $L$. We are given a period $P$, a routing function ${\cal R}$ and a bijection $\rho:L\rightarrow S$ which assigns a BBU to each RRH. Let ${\cal C}_{\rho} = \{(l,\rho(l))\}_{l \in L} \cup \{(s,\rho^{-1}(s))\}_{s \in S}$. Let consider a $P$-periodic assignment of ${\cal C}_{\rho}$ which associates $m_l$ to 
%       $(l,\rho(l))$ and $m_{\rho(l)}$ to $(\rho(l),l)$.  
      
      
      \begin{center}
      \includegraphics[scale=0.3]{rrh.png}
      \end{center}
      
      

      This message is received by $\rho(s)$ at time $t(\rho(s),r)$. It is then sent back to $s$ on the route $\rho(r)$ in the same period at time $m_{\rho(s)}$ if $m_{\rho(s)} > t(\rho(s),r)$, otherwise at time $m_{\rho(s)}$ in the next period. The time between the arrival of the message and the time it is sent back is called the \textbf{waiting time} and is defined by $w_s = m_{\rho(s)} - t(\rho(s),r)$ if $m_{\rho(s)} > t(\rho(s),r)$ and $w_s = m_{\rho(s)} + P - t(\rho(s),r)$ otherwise.
      
       \begin{center}
      \includegraphics[scale=0.3]{BBU2.png}
      \end{center}
     

      When a BBU receives a message, it must compute the answer before sending it back to the RRH. This time can be encoded
      in the last arc leading to the BBU and thus we need not to consider it explicitly in our model.
    
      Thus, the whole process time for a message sent at vertex $s$ on the route $r$ is equal to
      $$
      PT(s)=\lambda(r)+ w_s+\lambda(r).
      $$
      
      In the process time, we count the time between the first time at which a message is emitted and 
      the first time at which the message comes back. Alternatively we could consider the time between the emission of the first slot and the reception of the last slot of the message, which would add $\tau$ to the process time.
      However, since all messages are of size $\tau$, it will not change the problem we solve in the rest of the article and that we now introduce.
      
    The {\bf maximum process time} of the $(P,\tau)$-periodic assignment ${\cal M} $ is defined by $MT({\cal M})=\max\limits_{s \in S} PT(s)$. We consider the following decision problem.

      \noindent {\bf Periodic Assignment for Low Latency (PALL)} 

      \noindent {\bf Input:}  A symmetric routage graph $(G,{\cal R})$, a period $P$, an integer $\tau$, an integer $T_{max}$.

      \noindent {\bf Question:} does there exist a $(P,\tau)$-periodic assignment ${\cal M}$ of $(G,{\cal R})$ such that $MT({\cal M}) \leq T_{max}$?

      As a consequence of the $\NP$-hardness of PRA, we show in the next subsection that this problem is $\NP$-hard. 
      In Sec.~\ref{sec:PALL} we will study heuristics which try to solve the search version of PALL (computing an assignment), also denoted by PALL for simplicity.

  
\section{Hardness of PRA}
  \label{sec:complexity}

 In this section we always assume that the size of a message $\tau$ is equal to one. 
 We will prove the hardness of PRA and PALL for $\tau =1$ which implies the hardness of the general problems. 
Consider an instance of the problem PRA, i.e., a routage graph $(G,\cal{R})$ and a period $P$.
The {\bf conflict depth} of a route is the number of other routes which share an edge with it. 
The conflict depth of a routage graph $(G,\cal{R})$ is the maximum of the conflict depth of the routes in $\cal{R}$.
The {\bf load} of a routage graph is the maximal number of routes sharing the same arc.
Remark that a $(P,1)$-periodic assignment must satisfy that $P$ is larger or equal to the load.


We give two alternate proofs that PRA is $\NP$-complete.
The first proof works already for conflict depth two. Remark that for conflict depth one,
the graph can be seen as a set of disjoint pair of routes, on which PRA and PALL can be solved in linear time. 
 The second proof reduces the problem to graph coloring and implies inapproximability when one tries to find the smallest possible $P$. \\

 \begin{proposition}
Problem PRA is $\NP$-complete, when the routing is of conflict depth two.
\end{proposition}
 \begin{proof}
 The problem $PRA$ is in $\NP$ since given an offset for each route in an assignment, it is easy to check in linear time in the number of edges whether there are collisions.
 
  Let $H=(V,E)$ be a graph and let $d$ be its maximal degree. We consider the problem to determine whether $H$ is edge-colorable
  with $d$ or $d+1$ colors. The edge coloring problem is $\NP$-hard~\cite{holyer1981np} and we reduce it to PRA to prove its $\NP$-hardness. We define from $H$ an instance of PRA as follows. 
  For each $v$ in $V$, the graph $G$ has two vertices $v_1, v_2$, and for each $(u,v) \in E$,the graph G has two vertices $s_{u,v}, t_{u,v}$. Set an arbitrary orientation of the edge $(u,v)$, such that the following route is directed from $u$ to $v$.
%   The set $A$ of arcs of $G$ is: 
%   $$ \{(v_1,v_2) \mid v\in V\} \cup \{(u_2,v_1)\mid u \neq v \in V^2\} \cup \{(s_{u,v},u_1),(v_2,t_{u,v}) \mid (u,v) \in E \}. $$
  For each edge $(u,v) \in E$, there is a route $s_{u,v},u_1,u_2,v_1,v_2,t_{u,v}$ in ${\cal R}$.  
  All these arcs are of weight $0$. The set of arcs of G is the union between all the arcs of the previous routes.
   
    
  Observe that the existence of a $d$-coloring of $H$ is equivalent to the existence of a $(d,1)$-periodic assignment
  of $(G,{\cal R})$. Indeed, a $d$-coloring of $H$ can be seen as a labeling of its edges by the integers
  in $\{0,\dots,d-1\}$ and we have a bijection between $d$-colorings of $H$ and offsets of the routes of ${\cal R}$.
  By construction, the constraint of having no collision between the routes is equivalent to the fact that no two adjacent edges have the same color. Therefore we have reduced edge coloring to PRA which concludes the proof. 
 \end{proof}
 
 Remark that we have used zero weight in the proof. If we ask the weights to be strictly positive, which makes sense in our model since
they represent the latency of physical links, it is easy to adapt the proof. We just have to set them so that in any route the delay at $u_1$ is equal to $d$ and thus equal to $0$ modulo $d$. We now lift this hardness result to the problem PALL.

\begin{corollary}
Problem PALL is $\NP$-complete for routing of conflict depth two.
\end{corollary}
\begin{proof}
 We consider $((G,{\cal R}),P,\tau)$ an instance of $PRA$. We assume that no vertex is the first of some route and the last of another one. Remark that this condition is satisfied in the previous proof, which makes the problem $PRA$ restricted to this kind of instance $\NP$-complete. 
 Let us define $T_{max} = 2 \times \max_{r \in {\cal R}} \lambda(r) + P$. We define $(G',{\cal R}')$ a symmetric routage graph from $(G,{\cal R})$ where for every route we add a symmetric route with new arcs of opposite orientation and the same weights.
 The instance $((G',{\cal R'}),P,\tau,T_{max})$ is in PALL if and only if $((G,{\cal R}),P,\tau)$ is in $PRA$. Indeed the waiting time of each route is by definition less than $P$ and thus the maximal process time is always less than $T_{max}$. Moreover a $(P,\tau)$-assignment of $(G,{\cal R})$ can be extended into a $(P,\tau)$-assignment of $(G',{\cal R'})$ in the following way. For each route $r \in \cal{R}$ starting at $s$, the time at which the message arrives is $t(\rho(s),r)$, then we choose as offset for $\rho(r) \in \cal{R}'$ $-t(\rho(s),r) \mod P$. The symmetry ensures that each new route $\rho(r)$ in ${\cal R'}$ uses the same times slot as $r$ one each of its node and thus avoid collisions.
\end{proof}

Let MIN-PRA be the problem, given a routage graph and an assignment, to find the minimal period $P$ such that there is a $P$-periodic assignment. 

\begin{theorem}\label{th:inapprox}
 The problem MIN-PRA cannot be approximated in polynomial time within a factor $n^{1-o(1)}$, with $n$ the number of routes, unless $\P = \NP$ even when the load is two.
\end{theorem}

\begin{proof}
 We reduce graph coloring to PRA. Let $H$ be a graph instance of the $k$-coloring problem. 
 We define ${\cal R}$ in the following way: for each vertex $v$ in $H$, there is a route $r_v$ in ${\cal R}$.
 Two routes $r_v$ and $r_u$ share an arc if and only if $(u,v)$ is an edge in $H$; this arc is the only one shared by these two routes. All arcs are of delay $0$. 
 
 Observe that the existence of a $k$-coloring of $H$ is equivalent to the existence of a $(k,1)$-periodic assignment in $G$, 
 by converting an offset of a route into a color of a vertex and reciprocally. Therefore if we can approximate the minimum value of $P$ within some factor, we could approximate the minimal number of colors needed to color a graph within the same factor. The proof follows from the hardness of approximability of finding a minimal coloring~\cite{zuckerman2006linear}.
\end{proof}


In particular, this reduction shows that even with small maximal load, the minimal period can be large.

    \begin{figure}[ht]
    
    \scalebox{0.5}{
    \begin{tikzpicture}
    \tikzset{
      LabelStyle/.style = { rectangle, rounded corners, draw,
			  font = \bfseries },
      EdgeStyle/.append style = {->} }
      \SetGraphUnit{5}
      
      
      \node[draw,circle] (s3) at (4, 2) {$s_2$}; 
      \node[draw,circle] (s2) at (0, 4) {$s_1$}; 
      \node[draw,circle] (s1) at (0, 6) {$s_0$}; 

      \node[draw,circle] (t3) at (12, 3) {$t_2$}; 
      \node[draw,circle] (t2) at (14, 4) {$t_1$}; 
      \node[draw,circle] (t1) at (10, 2) {$t_0$}; 
      

      \tikzstyle{VertexStyle}=[shape = circle, draw, minimum size = 20pt]
	\tikzset{
      VertexStyle/.append style = {blue} }
	\Vertex[x=-8,y=3]{1}
	      \tikzset{
      VertexStyle/.append style = {green} }
	  \Vertex[x=-7,y=5]{2}

	    \tikzset{
      VertexStyle/.append style = {red} }
	  \Vertex[x=-6,y=4]{3}
		\tikzset{
      VertexStyle/.append style = {black} }
      
      
      \SetVertexNoLabel
      \Vertex[x=2,y=5]{A}
      \Vertex[x=4,y=5]{B}
      \Vertex[x=10,y=5]{C}
      \Vertex[x=12,y=5]{D}
      \Vertex[x=6,y=3]{E}
      \Vertex[x=8,y=3]{F}
      \tikzset{
      EdgeStyle/.append style = {green} }
      \Edge(s2)(A)
      \Edge(A)(B)
      \Edge(B)(C)
      \Edge(C)(D)
      \Edge(D)(t2)

      
      \tikzset{
      EdgeStyle/.append style = {red} }
      \Edge(s3)(E)
      \Edge(E)(F)
      \Edge(F)(t3) 
	\tikzset{
      EdgeStyle/.append style = {blue} }
      \Edge(s1)(A)
      \Edge(A)(B)
      \Edge(B)(E)
      \Edge(E)(F)
      \Edge(F)(t1)
      
	\tikzset{
      EdgeStyle/.append style = {black,-} }

      \Edge(1)(2)
      \Edge(1)(3)
    \node (1) at (-3,4){\Huge $\rightarrow$};
%     
%     \node (2) at (-7,0){\Huge H};
%     \node (3) at (10,0){\Huge G};
    \end{tikzpicture}
    }
    \caption{Reduction from k-coloring to MIN-PRA}

    \end{figure}
    
\section{The star topology: no waiting time} \label{sec:PAZL}
  
   
    
    \subsection{The star topology}
    
      From now on, we will only consider graphs with a very simple topology that we call the {\bf star topology}. 
      First, for each arc $(u,v)$, there is also an arc $(v,u)$ with the same weight.
      There are two sets of vertices, $S=\{s_1,...,s_n\}$ and $T=\{t_1,...,t_n\}$ of cardinality $n$ and two special nodes
      the central source node {\bf $c_s$} and the central target node {\bf $c_t$}. There is an arc between {\bf $c_s$} and {\bf $c_t$} shared by all routes. For all $i$, there is an arc between $s_i$ and $c_s$ and between $t_i$ and $c_t$.
      The routes are the directed paths $r_i = s_i,c_s,c_t,t_i$ and $\rho(r_i) = t_i,c_t,c_s,s_i$ and we have thus defined a 
      symmetric routage graph. 
      
      
       \begin{center}
	 
\begin{tikzpicture}

\tikzset{
  LabelStyle/.style = { rectangle, rounded corners, draw,
                       font = \bfseries },
  EdgeStyle/.append style = {->} }

  \SetGraphUnit{5}
  
  \node[draw,circle] (s3) at (0, 0) {$s_2$}; 
  \node[draw,circle] (s2) at (0, 2) {$s_1$}; 
  \node[draw,circle] (s1) at (0, 4) {$s_0$}; 

  \node[draw,circle] (t3) at (8, 0) {$t_2$}; 
  \node[draw,circle] (t2) at (8, 2) {$t_1$}; 
  \node[draw,circle] (t1) at (8, 4) {$t_0$}; 
  

  \node[draw,circle] (cs) at (2, 2) {$c_s$}; 
  \node[draw,circle] (ct) at (6, 2) {$c_t$}; 

  
  \Edge(s1)(cs)
  \Edge(s2)(cs)
  \Edge(s3)(cs)
  
  \Edge(ct)(t1)
  \Edge(ct)(t2)
  \Edge(ct)(t3)
  
  \Edge(cs)(ct)

  
\end{tikzpicture}

  \end{center}
	
      Since the central arc appears in every route, its value does not matter when considering assignments.
      We assume the weight of the central arc to be $0$ \\
      Collisions between messages can only appear at node $c_s$ on the way forward and at node $c_t$ on the way back.
      Thus, we only have to check if there is no collisions in a given period at those two vertices.
      We will refer to the period at $c_s$ as the {\bf forward period}, and the period at $c_t$ as the {\bf backward period}. A message issued on the route $r$ at time $m_r$ will reach $c_s$ at time $m_{r} + t(c_s,r) \mod P$ in the forward period. If the offset of $\rho(r)$ is $m_\rho(r)$, the answer will reach $c_t$ at time $m_{\rho(r)} + t(c_t,\rho(r))\mod P$ in the backward period.

      A $(P,\tau)$-periodic assignment is the choice for all $i < n$, of $m_{r_i}$ and $m_{\rho(r_i)}$ such that, for any couple $(i\neq j)$, we have $[t(c_s,r_{i})] \cap [t(c_s,r_{j})] = \emptyset$ and $[t(c_t,\rho(r_i))] \cap [t(c_t,\rho(r_j))] = \emptyset$.

      

  \subsection{Solving PAZL}
  
  In this subsection, we deal with a simpler version of the problem PALL.
  We ask for a $(P,\tau)$-periodic assignment {\bf with all waiting times equal to $0$} and we call this restricted problem {\bf Periodic Assignment for Zero Latency} or PAZL. 
  In that case $MT({\cal M})$ is equal to twice the delay of the longest route, thus $T_{max}$ is not relevant anymore. 
  Since $w_i=0$, choosing $m_i$, the offset of the route from $s_i$ to $t_i$, also sets the offset of the route from $t_i$ to $s_i$ to $m_i + \lambda(r_i) \mod P$.
  Remark that there is a bijection between the assignment of a star topology and the 
  the assignment of the same star topology where all arcs from $s_i$ to $c_s$ have weight equal to $0$
  by changing $m_i$ into $m_i - t(c_s,r_i) \mod P$. Therefore we assume from now on that the \emph{weight of the arcs from $s_i$ to $c_s$ are all equal to $0$}.
  
  \todo{Dire qu'on donne deux algos qui trouvent toujours une solution quand certains condtions sont remplies
  et un dernier qui sait d√©cider si il y a une solution oui ou non mais qui est exponentiel avec des optimisations pour le rendre pratique}
  
  We propose two algorithm that give solutions in polynomial time following some criteria (short routes or great enough period), and one exponential algorithm which determines if there is a solution, and find it if it exists.
  
    \subsubsection{Shortest-longest policy}
    

    
    We present a simple policy, which works when the period is large with regards to the delay of the routes.
    The message are sent in order from the shortest route to the longest route, without any gap between two messages in the forward period.
    In other words, we assume that the route $r_i$ are sorted by increasing $\lambda(r_i)$ and we set $m_{s_i} = i\tau$.
    We call this algorithm {\bf Shortest-Longest}.
      
     By definition, there are no collision in the forward period and if the period is long enough, 
     it is easy to see that in the backward period the order of the messages are the same as in the forward period and that no collision can occur. 
      
      
      \begin{proposition} When $n\tau + 2(\lambda(r_{s_{n-1}}) - \lambda(r_{s_0})) \leq P$,
      the algorithm Shortest-Longest solves positively PAZL in time $O(n\log(n))$.\label{prop:SL}
      \end{proposition}
      \begin{proof}
       Since $m_{s_i} = i\tau$, $[t(c_s,r_{s_i})] = \{i\tau,\dots, (i+1)\tau -1\}$ and there are no collision on the forward period.
       
       
       We assume may that $\lambda(r_{s_0}) = 0$, since removing $\lambda(r_{s_0})$ to every route does not change the order on the length of the routes and thus the result of this algorithm.
      We have  $[t(c_s,r_{t_i})] = \{2 \lambda(r_{s_i}) + i\tau, \dots,  2 \lambda(r_{s_i}) + (i+1)\tau -1\}$ since $2 \lambda(r_{s_{n-1 }}) + n\tau \leq P$.
       Since $ \lambda(r_{s_i}) \leq  \lambda(r_{s_{i+1}})$ by construction, we have  $2 \lambda(r_{s_i}) + (i+1)\tau -1 < 2 \lambda(r_{s_{i+1}}) + (i+1)\tau$ which proves that there are no collision on the backward period. 
       
       The complexity of the algorithm is dominated by the sorting of the routes. 
      \end{proof}

      
      If the period is slightly smaller that the bound of Proposition~\ref{prop:SL}, a collision will occur on the route in the backward period, making 
      this policy not useful even as a heuristic for longer routes. 

   
    \subsubsection{Greedy Algorithm}
    
    We propose a greedy algorithm to build a $(P,\tau)$-periodic assignment, which provably works when
    the period is large enough with regards to the number of routes and size of messages. In other words, 
    we can always find a solution when the network is far from saturated. 
    
    \begin{proposition}
    Let  $n$ be the number of routes and let $ 3n\tau \leq P$, then there is an algorithm which positively solves PAZL in time $O(n^2)$.
    \end{proposition}
    \begin{proof}
     We consider the forward period and cut it into consecutive interval of size $\tau$ that we call macro-slots. The algorithm works by choosing an offset for each route in the following way: try all offsets which put the message in a yet not used macro-slot in the forward
     period. The choice of an offset also fixes the position of the message in the backward period, chose the first one which does not create a collision. We now prove that this algorithm always finds a $(P,\tau)$-periodic assignment without waiting time when $P \geq 3n\tau$.
     
     Assume we are choosing the offset of the route $r_{k+1}$, we have at least $P - k \geq 3n - k$ free macro-slots in the forward period, since $P \geq 3n\tau$. Each of these $3n - k$ possible offset values translates into $3n - k$ positions of messages in the backward period. All these positions are separated by at least $\tau$ slots. There are already $k$ messages of size $\tau$ in the backward period. One such message can intersect at most $2$ potential positions since they are disjoint intervals. Therefore  amongst the possible $3n - k$ positions, there are  at least $3n - k -2k$ which are without collision. Since $k < n$, $3n - k -2k \geq 1$, which proves that the algorithm terminates and find a  $(P,\tau)$-periodic assignment. 
     
     This algorithm works with a complexity $O(n^2)$, since for the $k^{\text{th}}$ route we have to try at most $2k$ offsets before finding a correct one. We can test the $2k$ offsets of the backward period in time $O(k)$ by maintaining an ordered list of the intervals used by already set routes.
     \end{proof}
     
      \begin{center}
      \includegraphics[scale=0.3]{ex3nt.png}
      \end{center}
% 	\begin{algorithm}[H]
% 	\caption{Greedy assignment}
% 	\begin{algorithmic}
% 	\REQUIRE ${\cal R}_{\cal C}$, period $P$
% 	\ENSURE A P-periodic assignment in p $\leq P$, or FAILURE
% 	\STATE $T$ a table of the macro slots of size $\tau$ in the forward period.
% 	\STATE $L$ a list of free intervals in the backward period%$P2[P]$ slots backward period.
% 	\FORALL{source $s$ in S}
% 
% 	\FORALL{free intervals $[a,b]$ in $L$}
% 	\FORALL{ $a/\tau - \lambda(s) <j< b/\tau - \lambda(s)$ }
% 	\IF{ $T[j] == FREE$}
% 	\STATE $m_{s} \leftarrow j.\tau$
% 	\STATE $T[j] = USED$
% 	\STATE update $[a,b]$ in $L$
% 	\STATE BREAK
% 	\ENDIF
% 	\ENDFOR
% 	\ENDFOR
% % 	
% % 	\IF{No intervals are found for $s_i$}
% % 	\STATE return FAILURE
% % 	\ENDIF
% % 	\ENDFOR
% 
% 	\ENDFOR
% 
% 	\end{algorithmic}
% 	\end{algorithm}
	
This algorithm, contrarily to the previous one, may work well, even when the condition $P \geq 3n\tau$ is not true.
In fact, experimental data in Subsection~\ref{sec:experimental_results} suggests that the algorithm finds a solution on average when $P \geq 1.5 n\tau$.
Note that we also experimented with other greedy algorithms which do not use macro-slots, they work even better in practice but their theoretical upper bound is worse.

	\subsubsection{Exhaustive search}
% 	\begin{algorithm}[H]
% 	\caption{Exhaustive Generation}  
% 	\begin{algorithmic}
% 	\REQUIRE A routage graph ${\cal R}_{\cal C}$, period $P$, packet size $\tau$
% 	\ENSURE $(P,\tau)$-periodic assignment of ${\cal R}_{\cal C}$
% 	\STATE Forward-budget $\leftarrow$ $P$ - n * $\tau$
% 	\STATE Backward-budget $\leftarrow$ $P$ - n * $\tau$
% 	\STATE Free-Intervals $\leftarrow$ list of free intervals in the backward period, init to $[0;P[$
% 	\FORALL{source $s_i$ in S}
% 	\FORALL{j in Free-Intervals }
% 	\IF{Message of the route $r_{s_i}$ does not collides with scheduled routes}
% 	\STATE $m_{s_i} \leftarrow $ the first slot of Free-Intervals[j]
% 	\STATE Split the Free-Intervals considering the new packet
% 	\STATE Forward-budget $\leftarrow$ Forward-budget - {\em lost size}
% 	\STATE Backward-budget $\leftarrow$ Backward-budget - {\em lost size}
% 	\STATE call Exhaustive Generation on remaining routes
% 	\ENDIF
% 	\ENDFOR
% 	\ENDFOR
% 
% 
%       \end{algorithmic}
%       \end{algorithm}

% 	    
      We now present an exhaustive search algorithm, which tries to set the offsets in all possible ways until it has found a $(P,\tau)$-periodic assignment. Contrarily to the two previous algorithms, when it fails to find a solution, then it certifies there are no solution to PAZL.
      
      We have $n$ routes denoted by $\{0,\dots,n-1\}$. A partial solution $S$ is 
      a partial function from $[n]$ to $\{0,1,\dots,P-\tau -1\}$ which sets a starting time for a subset of the routes $R(S) \subseteq [n]$, such that there are no collisions for these routes.  A partial solution $S'$ extends $S$, if $S'$ is defined over one more route than $S$ and this route has a larger starting offset than all routes of $S$: $R(S') = R(S) \cup \{r'\}$ and for all  $r \in R(S)$, $S(r) + \tau \leq S'{r'}$. We define a tree whose nodes are partial solutions and such that the root is the empty partial solution and 
      the children of a partial solution are the partial solutions which extend it. The solutions to our problem will be the leaves of depth $n$ in the tree, therefore our algorithm is a depth-first search of the tree. 
      
      Remark that a node $S$ with $|R(S)| = k$ can have as many as $(n-k)P$ children. Since the tree is of depth $n$, the tree may have as many as $n!P^n$ elements and while $n$ is small, $P$ may be large which makes its traversal intractable.  Therefore we have to find cuts in the tree to avoid to explore it entirely and henceforth make the algorithm practical. Cuts correspond to the detection of subtrees which contain no solutions and can thus be skipped.   
      We now propose three cuts, the first two being particularly useful when the network is loaded ($n\tau$ is not far from $P$). 
      
      \begin{enumerate}
       \item We consider the number of slots which can be used by routes not yet fixed by a partial solution in the \emph{forward period}. When we extend a solution into $S$ by a route at offset $m$, then at most $(P - m) / \tau $ routes can still be set without collisions in the forward period. If that value is less than the number of routes which are not in $R(S)$, it is a failure and the algorithm backtracks.
       
       \item 
       For the next two cuts, we need to define the notion of the useful slots of a partial solution $S$ in the \emph{backward period}: a slot is said to be useful, if it is not used by a message set by $S$ in the backward period and it belongs to an interval of at least $\tau$ such slots. Useful slots are positions which can be used when extending $S$. We will denote by $([a_i,b_i[)_{i\leq l}$ the ordered sequence of intervals of useful slots of $S$. Without loss of generality we can assume that all $a_i, b_i \leq l$. The number of messages of size $\tau$ which can be placed in the useful slots of $S$ is thus  $\displaystyle{ \sum_{i=0}^{l} (b_{i} -a_i)/\tau } $. If that value is less than the number of routes which are not in $R(S)$, it is a failure and the algorithm backtracks. Notice that the list of intervals of useful slots and the value $\displaystyle{ \sum_{i=0}^{l} (b_{i} -a_i)/\tau } $ can be maintained in constant time, since each time a route is added, we only need to split an interval of useful slots into at most two such intervals.
       
       
       \item 
       Let $S_1$ and $S_2$ be two partial solutions with $R(S_1) = R(S_2)$. Let $US_1$ (respectively $US_2$) be the set of useful slots of $S_1$ (resp. $S_2$). We say that \emph{$S_1$ dominates $S_2$} if there are more useful slots both in the forward and backward periods for $S_1$ than for $S_2$. Formally, the largest offset fixed in $S_1$ is smaller than the one in $S_2$ and $US_2 \subseteq US_1$. Remark that any valid sequence of extensions of $S_2$ (choosing offsets of routes in the complementary of $R(S_2)$) is also a valid sequence of extensions of $S_1$. Therefore if the tree rooted at $S_2$ contain a solution, then $S_1$ contains one too. Hence, in our exhaustive search of the tree of partial solutions, we can skip the tree rooted at $S_2$.
       
       We now explain how we can detect some partial solutions which are dominated so that we do not explore their subtrees.
       Consider a partial solution $S$ which we extend into $S'$ by setting the offset of the route $r$ to be the smallest possible. The offset of $r$ in the backward period is $S'(r)+ \lambda$ and we denote the end of the message before before by $a$. Hence all extensions of $S$ into $S''$ such that $S'(r)  < S''(r) < a + \tau - \lambda$ are dominated by $S'$. Therefore when computing the extension of $S$, we first build $S'$ and then $S''$ with $S''(r) =  a + \tau - \lambda$ , skipping all values in between.
       
       \end{enumerate}
      
      The third cut works well in conjunction with the first one since it makes the offsets grow quickly and 
      which makes the first cut more likely to apply. A last cut could be implemented: compute for every route not in $R(S)$ the set of possible positions in the backward period and verify whether at least one is contained in the useful slots of $S$.


    \subsubsection{Experimental Results}\label{sec:experimental_results}
      
      The following experimental results compare the three presented algorithms.
      Notice that both Greedy algorithm and Shortest-Longest are polynomial time algorithm but are not always able to find a solution. On the other hand, the exhaustive search will find an optimal solution, if it exists, but works in exponential time. We will compare the performance of the algorithms in two different regimes: the routes are either short with regards to $\tau$ and $P$ or unrestricted.
      We choose the parameter realistic with regard to our C-RAN context. The number of routes 
      is at most $n = 20$, $\tau$ is equal to $2500$ and the period is at most $3n\tau$ (otherwise the greedy algorithm always returns a solution). 
      
      \todo{Dire o√π on peut trouver le code (pas la peine de donner des infos sur la machine/compilateur car one ne fait pas d'√©tude de performances.}
%             
%             The graphs 
%       To correspond with the C-RAN applications, we made some simulations on graphs in which $\lambda(c_s,r_{s_i})$ and $\lambda(c_t,r_{t_i})$, are drawn following an uniform act between 0 and 700 slots, that is, at the most, 5 km between the RRH and its BBU. The messages size $\tau$ is to 2500 slots, that is, approximately 1.228 Gbps of data for each route. The size of a slot is given by the time taken to send 64 bytes on the network, in which the links has 10Gbps throughput.
% 
%       \todo{Mettre les donn√©es concr√®tes plus proprement et √©ventuellement ne pas les mettre si on envoie pas √† un truc de t√©l√©com}

      \paragraph{Short routes}
      
      First we consider routes which are shorter than $\tau$, that is a message cannot be contained 
      completely in a single edge. This is typical in our context and we will consider graphs in which the values $\lambda(c_t,r_{t_i})$ are drawn uniformly between $0$ and $700$ slots. It corresponds to messages of approximately 1Mb, links of bandwidth 10Gbps and length less than 5km between the BBU and the RRH. 
      

      
      Our aim is to understand how well the algorithms are working when the network has a high load (when 
      the load is low, the greedy algorithm always returns a solution). To do that we try to evaluate the 
      minimal period for which a $(P,\tau)$ periodic assignment can be found by each algorithm. 
      To that end we do a linear search on $P$, since a dichotomy would not work because of Lemma~\ref{lemma:monotonic}.
      
      
      In our experiment, we generated $1000$ random instances of PAZL for $1$ to $12$ routes. 
      We measured the average minimal period, for each algorithm. We needed to stop our experiments at $12$ routes since the exhaustive search was taking more than a second to finish on many instances.
      Note that the exhaustive search is optimal, that is it finds the best possible period for a given instance. 
      We also drew the functions $f(n) = n\tau$, which is an absolute lower bound on the period and $g(n) = 3n\tau$ which is the theoretical upper bound of the greedy algorithm.
      
      
        
      \begin{figure}

      \begin{center}
	\includegraphics[scale=0.4]{periode_petite.pdf}
      \end{center}
      \caption{Minimum period averaged over $1000$ random instances}
      \end{figure}
      
      First, we remark that the period found by the exhaustive search is only very slightly above the lower bound of 
      $n\tau$, which means that, in this regime, it is very well justified to look for a solution without waiting time even for a highly loaded network. 
      
      The period needed by Shortest-Longest to find an optimal solution is determined by the difference between the longest and the shortest route and could be easily determined theoretically. The algorithm was expected to be good since the routes are short, but it turns out it always finds the optimal solution in our experiments. Therefore, we should use it in practical application, in this regime, instead of the exhaustive search which is much more computationally expensive. 
      
      Finally we remark that the greedy algorithm have an average period much lower than the theoretical upper bound of $3n\tau$. We made a linear regression on this value and with a correlation coefficient greater than $0,999$ we find a slope of $1.53n\tau$.
      
      

      \paragraph{Long routes}
      
      We now want to understand the performance of these algorithms when the size of the routes are unbounded. When the routes are long, the cuts in the exhaustive search are less efficient and thus even for a small number of routes the algorithm may be impractical. To make the experimentations short enough, we have bounded the number of nodes of the tree of partial solutions the exhaustive search can visit by $10^9$.
      
      In this experiment we will fix the number of routes to $8$ and the values $\lambda(c_t,r_{t_i})$ are drawn following an uniform distribution between $0$ and $30000$ slots (in the same range as the period).
      We measure for each algorithm its percentage of success, for periods from $20000$ which is the minimum possible to $50000$.
      
      Since the exhaustive search can fail because there are no solutions or because it does not have enough time to finish its calculation. We represent both the success rate of the algorithm, and an upper bound on the success rate of any algorithm solving PAZL by combining its successes and its failures because of lack of time. 
      
\begin{figure}

       \begin{center}
      \includegraphics[scale=0.4]{echec_longues.pdf}
      \end{center}
      \caption{Success rate for $8$ routes over $1000$ random instances}
     \end{figure}
      
      In this regime, the performances of Shortest-Longest are abysmal since it depends on the difference between the longest and the smallest route
      which is large here. On the other hand, the greedy algorithm has a performance not very different from the case of short routes, which is expected since it does not depends on the size of the route.  \todo{Ajouter la moyenne pour la comparer aux routes courtes}
      
      When the period is less than $40000$, the exhaustive search find many more solutions than the greedy algorithms which justifies its use. 
      However for small period, less than $30000$ the computation time is really important and without improvement it would not be possible to tackle 
      larger problems with $10$ to $20$ routes. Moreover, examining the upper bound curve for small periods, we see that there are very few instances
      with a solution for PAZL. It means that with long routes and high load, looking for an assignment without waiting may be too restrictive.
      That is why we present algorithms for the general PALL problem in our next section. We will test them on $8$ long routes and a period between 
      $20000$ and $30000$ where, as we have shown here, there are often no easy to compute assignment without waiting time.
      
   \section{The star topology: minimizing latency}\label{sec:PALL}
    
    
	  We just found solution to solve a restricted version of PALL, in which no waiting times are allowed, 
	  and the problem has no solution when the period is too short. We propose to allow some message to wait in the target vertices (BBU), with the aim of giving an higher degree of freedom for the scheduling. Thus, the process time of a message $PT$ might be superior to $T_{max}$. The goal is to find some solutions with waiting time such that any message will be buffered too much, i.e. $MT({\cal M}) \leq T_{max}$.
	   


	\paragraph{Particular cases}
		
	One of the closest approach to real networks is the case in which all the weight on the arcs going from $c_t$ to targets are the same and so can be simplified by 0. In that case, the scheduling in the forward and backward period is the same. The trivial solution is to send all message following each others regardless the order. Thus, the period is minimal : $n.\tau$, where $n$ is the number of routes. Furthermore, all the waiting times are equal to 0 i.e. $w_i = 0,\forall i \in n$, thus, $MT({\cal M})$ is equal to twice the delay of the longest route, that is not alterable.

	Another particular case is the following one:	
	 \begin{theorem}
      There is always an optimal solution when all the weight on the arcs between $c_s$ and the sources are the same.
      \end{theorem}
      \begin{proof}
      

	Since we can simplify the weight on the arcs between $c_s$ and the sources, we consider only the delay between $c_t$ and the targets. Order the routes such that $\lambda(r_{s_i}) > \lambda(r_{s_j}), i<j$, i.e. the route 0 is the longest, and the route $n-1$ is the shortest one.
	The messages are sent in the forward period from 0 to $n-1$, that is $m_{s_i} = \tau * n$.
	The first message has totally reach the backward period at time $2.\lambda(r_{s_0})+\tau$. The process time of the first message is $PT(s_0) = 2.\lambda(r_{s_0}) $.
	The second message is eligible in the backward period at time $\tau + 2.\lambda(r_{s_1})$. Thus, the waiting time of the second route is $w_{s_1} = 2.\lambda(r_{s_0})+\tau - (\tau + 2.\lambda(r_{s_1})) = 2.(\lambda(r_{s_0}) - \lambda(r_{s_1}))$. Thus $PT(s_1) = 2.\lambda(r_{s_1}) + 2.(\lambda(r_{s_0}) - \lambda(r_{s_1}))  = 2.\lambda(r_{s_0})  = PT(s_0)$.
	By induction, $PT(s_i) = PT(s_0), \forall i \in n$. 
	Consequently, for this case, sending the message, because the longest route has no waiting time all the other routes has the exact same process time, thus, $MT(M) = PT(s_0) = 2.\lambda(r_{s_0}) $.
     \end{proof}


     \subsubsection{A first approach}
	
	To solve PALL, we proposed some heuristics that prioritize the longest routes, and thus helps to minimize $PT(s_i)$. Indeed, one can imagine that, if the messages on the longest routes are be less buffered in their target than the messages using the shortest routes, the process times might be balanced.
	In an optimal solution, if $i$ is the longest route, we want $w_i =0$, and $PT(s_i) = 2.\lambda(r_{s_i}) \geq  2.\lambda(r_{s_j}) + w_j = PT(s_j) $, where $j$ is any route $\neq i$.


     We first suggest the following heuristic, that prioritize the message on longest routes:

      On the forward period, for the first way, the messages are scheduled so that they are following each others, from the one using the longest route, to the one using the shortest route. Thus, we set the $m_{s_i}$ of the routes such that  $t(c_s,r_{s_i}) = \tau.i$, if the routes $r_i$ are ordered from the longest to the shortest.

      On $c_t$, the algorithm is the following one:


  \begin{algorithm}[H]

    \caption{Eligible route}
    \label{algorithm:Eligible}
    \begin{enumerate}
      
      \item To be eligible, a message needs to be able to come back on $c_t$ at the current clock (if clock = 0, or no messages are able to come back at this date, take the first message able to come back).
      \item Between the eligible messages, schedule first the one which has the lowest deadline.
      \item For any route i, the deadline correspond to $m_{s_i} + T_{max}-t(c_s,r_{s_i})$. This deadline corresponds to the latest date at which a message is able to quit the target switch without exceed $T_{max}$.

      \end{enumerate}
      
  \end{algorithm}
    

     
    \begin{algorithm}[H]
    \caption{Longest Shortest Greedy (LSG)}
    \begin{algorithmic}
    \REQUIRE routage graph ${\cal R_{\cal C}}$, period $P$, $ T_{max}$, packet size $\tau$
    \ENSURE $(P-\tau)-$periodic assignment of ${\cal R_{\cal C}}$
    \STATE $clock \leftarrow 0$
    \FORALL{route i in $r_{s_i}$ sorted from the longest to the shortest }
    \STATE  $m_{s_i} \leftarrow clock - t(c_s,r_{s_i}) \mod P$
    \STATE $clock \leftarrow clock + \tau$
    \ENDFOR

    \STATE take i such that $r_{t_i}$ is the eligible route (Algorithm \ref{algorithm:Eligible})
    \STATE $w_i \leftarrow 0$
    \STATE $clock = \lambda(r_i) + t(c_t,r_{t_i}) + \tau$
    \WHILE{there is a route which has not been scheduled}
    \STATE take i such that $r_{t_i}$ is the eligible route (Algorithm \ref{algorithm:Eligible})
    \IF{ the messages is able to come back before $clock$}
    \STATE $w_i = clock - t(c_t,r_{t_i}) - (m_i + \lambda(r_i))$ 
    \STATE $clock \leftarrow clock + \tau$
    \ELSE
    \STATE $w_i \leftarrow 0$
    \STATE $clock = \lambda(r_i) + t(c_t,r_{t_i}) + \tau$
   \ENDIF

    \ENDWHILE

    \end{algorithmic}
    \end{algorithm}
    
    By using a binary heap to manage the eligible routes, this algorithm runs in $\mathcal{O}(n\log{}n)$.
    
    This policy is split in two steps:
    \begin{enumerate}
    \item First, we choose arbitrary a sending order for the routes, and we set the offsets $m_i$ such that the messages are following each others in $c_s$.
    \item  Then, the schedule order in the way back is determined, considering the time at which the messages reach their target. 
    \end{enumerate}
     This {\em Greedy} policy determines the $m_{c_{s_i}}$, such that the messages does not collide on $c_t$. It computes the deadlines for every messages, considering their offsets and the delay on their routes, and determine the time at which the messages must leave their target, prioritizing the messages with the lowest deadlines.
     
     However, this heuristic does not take the period into account . Thus, a solution given by this algorithm can satisfy the constraint $MT({\cal M}) \leq T_{max}$, but this solution might need a too large period.

     \subsubsection{Sending order}
     
	We tried to look at the behavior of the that policy with different kind of sending order for the messages.
	
	We tried the five following sending policy, each ones determines an order in which the messages will be sent, but the messages are still following each others in $c_s$.
	
	The different sending policy that we tried are the following :
	\begin{enumerate}
	 \item Random: Generate $X$ random permutations for the routes and tries the greedy heuristic on the way back until we get an available $(P,\tau)$ periodic assignment. In the following experiments, we take $X = 100$.
	 \item Longest-Shortest on Routes (LSR): Send the messages from the one using longest to the one using shortest route (this is the sending order used in the previous heuristic).
	 \item Shortest-Longest on Routes (SLR): Send the messages from the one using shortest to the one using longest route
	 \item Longest-Shortest on last Arc (LSA): Send the messages from the one having the longest arc between $c_t$ an the target to the one having the shortest one.
	 \item Shortest-Longest on last Arc (SLA): Send the messages from the one having the shortest arc between $c_t$ an the target to the one having the longest one. This sending order gives us some $(P,\tau)$ periodic assignment in which all the $w_i = 0$, but needs a huge period if the difference between the longest and the shortest route is large (see proposition \ref{prop:SL}).
	\end{enumerate}
	
    
     
     For the rest of the section, we look at the different algorithm suggested to improve the second part of the scheduling, after having set the sending order.
      \subsubsection{About the periodicity}
     The previous algorithm is a greedy heuristic, which does not take the period into account. 
     We propose an improved version of the algorithm, still greedy, but which tries to compute some solution that satisfies the period $P$: When we try to schedule some messages $P$ slots after the first message scheduled, the algorithm mind the already scheduled messages, and avoid collisions with them.
     
     We first remember the date at which the first messages starts to come back through $c_t$. Let us note $bp$ this date.
     The greedy policy is the same until the message are scheduled in the period between $bp$ and $bp +P$. When a message is scheduled, we update a list of free intervals in the backward period.
     Once $clock > bp+P$, we consider that we are in the second period, and thus search a free interval after $clock$, large enough to put a message.
     
     This policy can significantly increase $w_i$, but ensures a periodic results. This {\ Greedy Periodic} policy is strictly better than Greedy, because it finds some solutions that greedy would not find, by considering the periodicity in the scheduling.
     
         We compared the two algorithms on 10000 graphs on which the weight of the links are drawn uniformly between 0 and 20000, with a period of 21000, and giving, for each instance $T_{max} = 2\lambda(r_{longest-route})$ . We then look at the success rate of each algorithms, with every sending order. Both algorithms reach the higher success rate with the Random sending order, but the success of Greedy is 5,65 \%, while the success rate of Greedy Periodic is to 30,02 \%.

    
     
     \subsubsection{Near from scheduling problems}
     
     The problem PALL is very similar to a scheduling problem, combined to the periodic aspect. Thus, the article ``A fast algorithm for single processor scheduling'', by Barbara Simons \cite{simons1978fast} gave us an optimal algorithm to schedule some jobs which has a release time, a deadline and the same execution time. We consider that the messages are the jobs, the release times are the date at which the messages are able to come back on $c_t$, and the deadlines are the latest date at which a message have to leave $c_t$ to comeback before $m_i + T_{max}$. This algorithm gives in $\mathcal{O}(n^2\log{}n)$ a solution with the earliest  possible completion time, if it exists. Thus, it tries to minimize the time between the first and the last message in the scheduling. Let us call {\ Minimized Scheduling (MS)} this algorithm.
     
     This algorithm uses the exact same main scheduling than Greedy. Nevertheless, when it tries to schedule a message that is not able to totally pass $c_t$ before it's deadline (let us call {\em crisis message} this message), the algorithm call a subroutine which, following some criteria, removes some previous messages from the scheduling such that the crisis message can be scheduled earlier. Then, the main scheduling routines is applied again. Some stopping conditions are able to detect if there is no solution for the given routage graph.
     
     If it exists a solution that satisfies the criteria $MT({\cal M}) < T_{max}$, this algorithm gives us a $(P,\tau)$ periodic assignment. Nevertheless, by setting the deadlines according to the size of the route only, the given $(P,\tau)$ periodic assignment might not respect the period $P$. 
     
     \subsubsection{Final algorithm}
     
     We adapted MS, presented in the previous paragraph, to consider the period, in the computation.
     
     
          
   
     
    \begin{algorithm}[H]
    \caption{ Minimized Scheduling Periodic (MSP)}
    \begin{algorithmic}
    \REQUIRE A routage graph ${\cal R_{\cal C}}$,a period $P$, packet size $\tau$, $ T_{max}$, the offsets $m_i$
    \ENSURE $(P-\tau)-$periodic assignment of ${\cal R_{\cal C}}$, if it exists
  
    \FORALL{route $r_{t_i}$}
    \STATE  $w_i \leftarrow 0$
    \STATE $end-period \leftarrow m_{s_i} + \lambda(r_{s_i}) + t(c_t,r_{t_i}) + P$
    \FORALL{route $r_{t_j}$}
    \STATE $deadline-route \leftarrow m_{s_j} + T_{max}-t(c_s,r_{s_j})$
    \STATE $deadline \leftarrow (deadline-route,end-period)$
    \ENDFOR
    
    \STATE Call (MS)

    
    \ENDFOR

    \STATE return the best $(P-\tau)-$periodic assignment, or FAILURE

    \end{algorithmic}
    \end{algorithm}
    
    This algorithm runs in $\mathcal{O}(n^3\log{}n)$. It tries for every routes of the routage graph, to fix the first route to comeback, and then determine the deadline of the other routes taking the minimum between the end of the period (determined by the first message that we fixed), and the deadline of the route itself(determined by $m_{s_i} + T_{max}-t(c_s,r_{s_i})$). 
    
    This algorithm finds more solutions than MS, because it decrease the deadlines of the route considering the periodicity. Thus, a scheduling given by this algorithm fulfill both the periodicity and the $T_{max}$ criteria. 
    
     The goal is to choose the best starting order, such that we have a good chance to have a $(P,\tau)$ periodic assignment, even with a small period, and T$_{max}$.
    
    \subsubsection{Results}
    
    To compare the previous algorithms, we first need to determine which of the sending order is the best. We know that Greedy Periodic is strictly better than Greedy, thus, we will compare the different sending orders with Greedy Periodic.

   In this experiment, we fix the number of routes to 8. We want to compare the sending orders with the worst parameters, so we draw the links between 0 and 20000 slots. We look at the success rate of each sending order with Greedy Periodic to schedule the messages in the way back. We give to  $T_{max}$ some {\em flexibility}. This flexibility represents $T_{max} - 2\lambda(r_{longest-route})$. We let this flexibility vary from 0 to 3000.
   
   We look at two different regimes: first, we take a period equal to $1,05n\tau$, and then, we take a greater period, that is, $1,5n\tau$. The following results are computed over 10000 instances.
     
\begin{figure}

       \begin{center}
      \includegraphics[scale=0.4]{departs_gp_21000.pdf}
      \end{center}
      \caption{Success rate of the sending orders for $P = 21000$}
     \end{figure}
     
     
       
\begin{figure}

       \begin{center}
      \includegraphics[scale=0.4]{departs_gp_30000.pdf}
      \end{center}
      \caption{Success rate of the sending orders for a $P = 30000$}
     \end{figure}
     
     First, we remark that, for any sending order, the success rate is strictly better for large periods. This is due to the fact that the size of the period is a factor for failure. According to our results, the two SL sending orders are not good, in any cases. However, the LS orders seem to increase when the flexibility is large enough, but in the two regimes, they appear to be stagnating to a lower success rate than Random. As we can see the random finds near to 100\% of the solutions when the period is large enough, even when we give no flexibility. On average, it is necessary to draw 6 randoms sending order to find a solution, when the period is large, but in some particularly hard instances, it can be impossible to find a solution, even with 100 randoms sending orders. 
     
     To observe  the impact of the number of random sending orders drawn, we compared the success rate of the following number of drawing, on graphs in which the links are drawn  between $0$ and $20000$ slots, with a period $P=20000$, and a flexibility of $0$.
       \begin{figure}

       \begin{center}
   \begin{tabular}{|c|c|c|c|c|c|}
    \hline
    number of randoms & $10$ & $100$& $1 000$& $10 000$&$100 000$\\
    \hline
    Success rate $(\simeq)$ & $60,5$&$77,7$&$80,5$&$80,5$&$80,5$\\
    \hline
      \end{tabular}
      \end{center}
   \caption{Impact of the number of randoms sending orders drawn}
     \end{figure}
     
     In our case of 8 routes, the number of different sending orders is $8! \simeq 40 000$. By drawing $1000$ random sending orders, we explore near to $2,5 \%$ of the cases, which seems enough to find as many solutions as if generate more random sending oredres.


     
     We now want to compare the performances of the different algorithms.Since GP showed some excellent results on large periods (see Figure 5), it is more interesting to focus on the behavior of the algorithms on short periods. The following experience is realized on graph with 8 routes (links between $0$ and $20000$), and with a period of 21000. Since we just conclude that drawing 1000 sending order is a good number, with 8 routes. We now generate 1000 randoms sending orders for the first way.
    

 
    \begin{figure}

       \begin{center}
      \includegraphics[scale=0.4]{retour_21000.pdf}
      \end{center}
      \caption{Success rate of the different algorithms for a $P = 21000$}
     \end{figure}
     
     
    
    \paragraph{Comparer optimal + depart random avec stochastique}
    
    \paragraph*{Future works}
   
   \begin{itemize}
    \item FPT algorithms for PAZL and PALL 
    \item average latency instead of maximal latency
    \item trees
    \item cycles 
    \item preemption (messages can be cut into pieces)
    \item routes are not given and can be chosen
   \end{itemize}

   


\bibliographystyle{ieeetr}
\bibliography{Sources.bib}

\end{document}
