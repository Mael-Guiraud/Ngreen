\documentclass[a4paper,10pt]{article}
\usepackage[utf8]{inputenc}
\usepackage{xspace}
\usepackage{url}
\usepackage{graphicx,graphics} 
\usepackage{color}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{algorithm}
\usepackage{algorithmic}
\usepackage{longtable}
\usepackage{complexity}
\usepackage{tkz-graph}
\usepackage{float}
\usepackage{setspace}
\renewcommand{\algorithmicrequire}{\textbf{Input:}}
\renewcommand{\algorithmicensure}{\textbf{Output:}}
  
\graphicspath{{figures/}}
\newcommand\rmatching{${\cal R}$-matching\xspace}
\newcommand\mdelay{$\cal M$-delay\xspace}
\newcommand\matchedgraph{{\bf matched graph}}
\newtheorem{proposition}{Proposition}
\newtheorem{theorem}{Theorem}

\setlength{\parskip}{1ex} % Espace entre les paragraphes

\newtheorem{fact}{Fact}
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{definition}{Definition}
\newtheorem{corollary}{Corollary}



\newcommand{\todo}[1]{{\color{red} TODO: {#1}}}


%opening
\title{Contention Management for 5G}
\author{DB,CC,MG,OM,YS}




\begin{document}

\maketitle
\begin{abstract}
This article treats about Contention Management for 5G.
\end{abstract}
The evolutions proposed in next generations of mobile network architectures aim at evolving toward centralized radio network architectures (C-RAN, for Cloud Radio Access Network) to reduce consumption costs and power at the base stations \cite{mobile2011c}. This type of architecture faces the challenge of mastering the latency in the transfer process between the Remote Radio Heads (RRHs) on the field and baseband units (BBUs) in the cloud. Low latency is already critical for the deployment of C-RAN approach. The standard requires meeting time constraints for functions like HARQ (Hybrid Automatic Repeat reQuest) that needs to be processed in less than from 1 to 10ms \cite{bouguen2012lte}
(depending on targeted services). One specificity in the C-RAN context is not only the latency constraint, but also the periodicity of the data transfer between RRH and BBU (this HARQ constraints must be enforced for each frame emitted every millisecond).\\
 Thus in this article, we work on latency and periodicity constraints in fronthaul.  The best current solution is to rely on an almost full optical approach, where each end-points (RRH on one side, BBU on the other side) are connected through direct fiber or full optical switches \cite{5gppparchitecture}. This architecture is very expensive and hardly scales in the case of a mobile network composed of about 10,000 base stations.  It is then needed to find a solution to offer low latency over commoditized packet based networks. Indeed,  dynamical optical bypass and dynamical management of the emission should be considered to guarantee latency constraints, as it is considered in the french ANR project N-GREEN. This project proposes a new type of switching/routing node and a specific network architecture exploiting WDM packets thanks to a new generation of optical add/drop multiplexers (WSADM: WDM slotted add/drop multiplexer). These packets having a fixed duration close to $1\mu $s are transported in a transparent way, to better exploit the switching matrix of the node; their headers will be transported over one dedicated wavelength at a lower bit rate, to reduce the physical constraints of the electronic processing and scheduler.\\
 Thus, new scheduling and routing paradigms and new technologies have to be considered to  guarantee  delay constrained periodic data transfers. One of the most promising approaches relies on the concept of Deterministic Networking (DN) such that one get rid of
 statistical multiplexing. The traditional queue managements are replaced by time based forwarding. Solutions for Deterministic
 Networking are under standardization in IEEE 802.1 TSN group \cite{finn-detnet-architecture-08}, as well at IETF DetNet working group \cite{ieee802}. Several patents on concepts and mechanisms for DetNet have been already published, see for example \cite{howe2005time,leclerc2016transmission}. To make DN working over a
 network composed of several nodes, it is required to manage the time at which the packets of deterministic paths are crossing each nodes. The major difficulty of this problem is the periodicity of the process. Indeed, a deterministic sending for the messages
between each pair BBU/RRH must not collide with the other messages sent by the others BBU/RRH in the same period, but also in the previous
and following periods.\\

Considering a graph, modeling the network topology, and a set of routes from source nodes (modeling connections to the BBU) and destination nodes (modeling the RRH) in this graph, the purpose is to select, for each destination node a route from one source node to it and a periodic routing scheme allowing to periodically sent a packet to each base station without congestion conflicts between all such packets and to insure a minimum latency. In a slotted time model, the aim is here to minimize the duration of the period, with a constraint of the maximum length of routes to be
selected. Even if the selected set of routes is given this optimization problem has been shown to be  \NP-hard. From an algorithmic point of view,
the purpose of this project is first, to study the complexity and the approximability of this problem when the length of the routes is small
(which corresponds to realistic cases), and secondly, to propose and implement some heuristics to solve this problem on realistic topologies.\\


This problem may look like wormhole problem \cite{cole1996benefit}, very popular few years ago, but here, we want to minimize the time lost in buffers and not just avoid the deadlock, and the wormhole does not treat about the periodicity. Several graph colorings have been introduced to model similar problems such as the allocation of frequencies \cite{borndorfer1998frequency}, bandwidths \cite{erlebach2001complexity}[17] or routes \cite{cole1996benefit}[18] in a network or train schedules \cite{strotmann2007railway}[19]. Unfortunately, they do not take into account the periodicity and the associated problems are also NP-complete. The only model which incorporates some periodicity is the circular coloring \cite{zhou2013multiple, zhu2001circular,zhu2006recent}but is not expressive enough to capture our problem.

\subsection*{Paper organisation}
 In the next section, ...


  

\section{Model}

  \subsection{Definitions}
  

  
	We consider a directed graph $G=(V,A)$ modelling a network. Each arc  $(u,v)$ in $A$ is labeled by an integer $dl(u,v) \geq 1$ that we call the delay and
	which represents the number of time slots taken by a signal to go from $u$ to $v$ using this arc. 
	%Note that for any arc $(u,v)$, $Dl(u,v)=Dl(v,u)$. Dominique voulait être plus général, on mettera cette propriété dans notre topologie
	
      A {\bf route} $r$ in $G$ is a sequence of consecutive arcs $a_0, \ldots , a_{k-1}$, with $a_i=(u_i,u_{i+1}) \in A$. 
      We will often refer to the first element of the route as a source and the last as a target.
      
      The {\bf latency} of a vertex $u_i$ in $r$, with $i \geq 1$, is defined by $$\lambda(u_i,r)= \sum\limits_{0 \leq j <i} dl(a_j)$$ We also define $\lambda(u_0,r)=0$.
      The latency of the route $r$ is defined by $\lambda (r)= \lambda (u_k,r)$.
      

      A {\bf routing function} $\cal R$ in $G$ associates to each pair of vertices $(u,v)$ a route from $u$ to $v$. Let $\cal C$ be an {\bf assignment} in $G$, i.e., a set of couples of different vertices of $G$. We denote by $\cal R_{\cal C}$ the set of routes ${\cal R}(u,v)$ for any $(u,v)$ in $\cal C$. We call $\cal R_{\cal C}$ a {\bf routage graph}, it contains all the informations needed in the forthcoming problems (assignment, routes and delays of the arcs). 
      

      \todo{Si on s'en sert, ajouter ici que le routage est cohérent.}

   \subsection{Slotted time Model}
      Consider now a positive integer $P$ called the {\bf period}. In our problem, we send messages in the network with period $P$. The time will thus be cut into slices of $P$ discrete slots. Assume we send a message at the source $s_i$ of the route $r_{s_i}$, at the time slot $m_{s_i}$ in the first period, then a message will be sent at time slot $m_{s_i}$ at each new period. We define the first time slot at which the message reaches a vertex $v$ in this route by $t(v,r_{s_i}) = m_{s_i} + \lambda(v,r) \mod P$. 

      A message usually cannot be transported in a single time slot. We denote by $\tau$ the number 
      of consecutive slots necessary to transmit a message. Let us call $[t(v,r_{s_i})]_{P,\tau}$ the set of time slots used by $r_{s_i}$ at a vertex $v$ in a period $P$, that is $[t(v,r_{s_i})]_{P,\tau} = \{t(v,r_{s_i}) + k \mod P \mid 0 \leq k < \tau \}$. Usually $P$ and $\tau$ will be clear from the context and we will denote $[t(v,r_{s_i})]_{P,\tau}$ by $[t(v,r_{s_i})]$.
      
      
      A {\bf $(P,\tau)$-periodic affectation} of a routage graph $\cal R_{\cal C}$ is a sequence  ${\cal M}=(m_{s_0}, \ldots ,m_{s_{n-1}})$ of $n$ integers that we call {\bf offsets}, with $n$ the number of routes in $\cal R_{\cal C}$. The number $m_{s_i}$ represents the index of the first slot used in a period  by the route $r_{s_i} \in \cal R_{\cal C}$ at its source $s_i$.
      A $(P,\tau)$-periodic affectation must have no {\bf collision} between two routes in $\cal R_{\cal C}$, that is $\forall (r_{s_i}, r_{s_j}) \in {\cal R_{\cal C}}^2, i \neq j$, % with $\tau$ the size (in number of consecutive slots) of each message that must be periodically sent on each route of ${\cal R}_{\cal C}$, 
      we have $$[t(u,r_{s_i})] \cap [t(u,r_{s_j})] = \emptyset .$$
      

%       Notice that the notion of $P$-periodic affectation \textbf{is not monotone} with regard to $P$. 
      As an example of a $(2,1)$-periodic affectation, let consider a routage graph with routes $\{r_{s_i}\}_{i=0,\dots,n-1}$, such that all pairs of routes intersect at a different edge.
      We set $\tau = 1$ and the delays are chosen so that if $r_{s_i}$ and $r_{s_j}$ have $v$ as first common vertex then we have $\lambda(v,r_{s_i}) - \lambda(v,r_{s_j})=1$.There is a $(2,1)$-periodic affectation by setting all $m_{s_i}$ to $0$.

%       A {\bf conflict graph} represents the collision between the routes of $ {\cal R}_{\cal C}$. The vertices of a conflict graph $G = (V,E)$ are the routes of $ {\cal R}_{\cal C}$, and there is an edge between two vertices if and only if there is a common arc between the two routes in $ {\cal R}_{\cal C}$.
%       
%       Given $u$ and $v$ two vertices of the conflict graph, corresponding to two routes colliding in $ {\cal R}_{\cal C}$. The weight of an edge, $w(u,v)$, is the absolute value of the difference between the distance of the two routes between their respective source node and the collision point.
%       
%       A labeling $F$ of such a graph is an affectation of an integer to each vertex, such that for each vertex $u$, $f(u) \neq f(v)+w(u,v)\mod P$, where $v$ are the neighbors of $u$ in the conflict graph and $P$ our period.
  
      \begin{figure}[ht]
       \begin{center}
      
\begin{tikzpicture}


\tikzset{
  LabelStyle/.style = { rectangle, rounded corners, draw,
                       font = \bfseries },
  EdgeStyle/.append style = {->} }
  \SetGraphUnit{5}
  \node[draw,circle] (s3) at (4, 2) {$s_2$}; 
  \node[draw,circle] (s2) at (0, 4) {$s_1$}; 
  \node[draw,circle] (s1) at (0, 6) {$s_0$}; 

  \node[draw,circle] (t3) at (14, 7) {$t_2$}; 
  \node[draw,circle] (t2) at (14, 4) {$t_1$}; 
  \node[draw,circle] (t1) at (10, 2) {$t_0$}; 

  
  \SetVertexNoLabel
  \Vertex[x=2,y=5]{A}
  \Vertex[x=4,y=5]{B}
  \Vertex[x=10,y=5]{C}
  \Vertex[x=12,y=5]{D}
  \Vertex[x=6,y=3]{E}
  \Vertex[x=8,y=3]{F}
  \tikzset{
  EdgeStyle/.append style = {green} }
  \Edge[label = 2](s2)(A)
  \Edge[label = 1](A)(B)
  \Edge[label = 2](B)(C)
  \Edge[label = 1](C)(D)
  \Edge[label = 1](D)(t2)

  
   \tikzset{
  EdgeStyle/.append style = {red} }
  \Edge[label = 2](s3)(E)
  \Edge[label = 1](E)(F)
  \Edge[label = 1](F)(C)
  \Edge[label = 1](C)(D)
  \Edge[label = 1](D)(t3) 
     \tikzset{
  EdgeStyle/.append style = {blue} }
  \Edge[label = 1](s1)(A)
  \Edge[label = 1](A)(B)
  \Edge[label = 1](B)(E)
  \Edge[label = 1](E)(F)
  \Edge[label = 1](F)(t1)

\end{tikzpicture}
      \end{center}
       \caption{A routage graph with $(0,\dots,0)$ as a $(2,1)$-periodic affectation}
      \end{figure}



   \subsection{Problems}

    We want to ensure that there is an affectation which allows to send periodic messages from sources to target
    without collisions. The problem we need to solve is thus the following:
    

      \noindent {\bf  Periodic Routes Assignment (PRA)} 

      \noindent {\bf Input:} a routage graph $\cal R_{\cal C}$, an integer $\tau$ and an integer $P$.

      \noindent {\bf Question:} does there exist a $(P,\tau)$-periodic affectation of $\cal R_{\cal C}$ ?


      We will prove in Sec.~\ref{sec:complexity} that the problem PRA is $\NP$-complete, even in restricted settings.
      Even approximating the smallest value of $P$ for which there is a $(P,\tau)$-periodic affectation is hard.

      An unusual property of affectation is that given a routage graph, we may have a $(P,\tau)$-periodic affectation but no
      $(P',\tau)$-periodic affectation with $P' > P$: the existence of an affectation is not monotone with regards to $P$.

	\begin{lemma} 
	 For any odd $P$, there is a routage graph such that there is $(2,1)$-periodic affectation but no $(P,1)$-periodic affectation.
	\end{lemma}
\begin{proof}

      Consider the routage graph ${\cal R_{\cal C}}$ given in the previous subsection. 
      We change the delays so that for $v$, the first vertex which belongs to $r_i$ and $r_j$,
      we have $\lambda(v,r_i) - \lambda(v,r_j)= P$, where $P$ is an odd number smaller than $n$, the number of routes in ${\cal R_{\cal C}}$. In such a graph, there is no $(P,\tau)$-periodic affectation, since the problem reduces to finding a $P$-coloring in a complete graph with $n > P$ vertices.\\
      If we consider a period of $2$, for all $i \neq j$, $\lambda(v,r_i) - \lambda(v,r_j) \mod 2 = 1$ . Therefore $(0,\dots,0)$ is a $(2,1)$-periodic affectation of ${\cal R_{\cal C}}$.

      
\end{proof}
      
% 
%       \begin{figure}[H]
%       \label{could-ran}
%       \begin{center}
%       % \begin{tabular}{cc}
%       \includegraphics[scale=0.5]{Total-latence.pdf}
%       \caption{Complete process for a leaf in $L$.}
%       \end{center}
%       \end{figure}
%       %\end{tabular}\newline

      
      In the context of cloud-RAN applications, we consider here the digraph $G=(V,A)$ modeling the target network 
      and two disjoint subsets of vertices $S$ and $T$ of equal cardinality, where $S$ is the set of RRHs and $T$ is the set of BBUs. 
      A \textbf{symmetric} assignment ${\cal C}$, is an involutive function from $S$ to $T$, which maps each element $s\in S$ to ${\cal C}(s)$ and ${\cal C}(s)$ to $s$. It can also be seen as the set of pairs $(s,{\cal C}(s))$ and $({\cal C}(s),s)$.\\
      The routing function ${\cal R}$ associates to each couple $(s,{\cal C}(s))$ a route called $r_s$ and to each couples $({\cal C}(s),s)$ a route called $r_{{\cal C}(s)}$.\\     
       We are given a period $P$, a routing function ${\cal R}$, and we consider a $(P,\tau)$-periodic affectation of ${\cal R}_{\cal C}$ which associates $m_s$ to the route $r_s$ which begins by $s$, and $m_{{\cal C}(s)}$ to the routes $r_{{\cal C}(s)}$ which begins by ${\cal C}(s)$.  This affectation represents the following process: first a message is sent at $s$, through the route $r_s$, at time $m_s$.
      
%       
%       We denote by $n$ the size of $S$ and $L$. We are given a period $P$, a routing function ${\cal R}$ and a bijection $\rho:L\rightarrow S$ which assigns a BBU to each RRH. Let ${\cal C}_{\rho} = \{(l,\rho(l))\}_{l \in L} \cup \{(s,\rho^{-1}(s))\}_{s \in S}$. Let consider a $P$-periodic affectation of ${\cal C}_{\rho}$ which associates $m_l$ to 
%       $(l,\rho(l))$ and $m_{\rho(l)}$ to $(\rho(l),l)$.  
      
      
      \begin{center}
      \includegraphics[scale=0.3]{rrh.png}
      \end{center}
      
      

      This message is received by ${\cal C}(s)$ at time $t({\cal C}(s),r_s)$. It is then sent back to $s$ in the same period at time $m_{{\cal C}(s)}$ if $m_{{\cal C}(s)} > t({\cal C}(s),r_s)$, otherwise at time $m_{{\cal C}(s)}$ in the next period. The time between the arrival of the message and the time it is sent back is called the \textbf{waiting time} and is defined by $w_s = m_{{\cal C}(s)} - t({\cal C}(s),r_s)$ if $m_{{\cal C}(s)} > t({\cal C}(s),r_s)$ and $w_s = m_{{\cal C}(s)} + P - t({\cal C}(s),r_s)$ otherwise.
      
       \begin{center}
      \includegraphics[scale=0.3]{BBU2.png}
      \end{center}
     

      When a BBU receives a message, it must compute the answer before sending it back to the RRH. This time can be encoded
      in the last arc leading to the BBU and thus we need not to consider it explicitly in our model.
    
      Thus, the whole process time for a message sent at vertex $s$ is equal to
      $$
      PT(s)=\lambda(r_s)+ w_s+\lambda(r_{{\cal C}(s)}).
      $$
      
      The message size $\tau$ in this process time, if we want to consider the time between the emission of the first slot and the reception of the last slot of the message. Since $\tau$ is the same for every routes, it does not change the calculations.
      
    The {\bf maximum process time} of the $(P,\tau)$-periodic affectation ${\cal M} $ is defined by $MT({\cal M})=\max\limits_{s \in S} PT(s)$. The problem we want to solve is the following. 

      \noindent {\bf Periodic Assignment for Low Latency(PALL)} 

      \noindent {\bf Input:}  A routage graph ${\cal R}_{\cal C}$ with ${\cal C}$ a symmetric assignment, a period $P$, an integer $\tau$, an integer $T_{max}$.

      \noindent {\bf Question:} does there exist a $(P,\tau)$-periodic affectation ${\cal M}$ of ${\cal R}_{\cal C}$ such that $MT({\cal M}) \leq T_{max}$?

      \todo{Si on veut, on peut parler du temps moyen aussi ici, seulement si on fait quelque chose dessus dans la suite}
      %The related optimisation problem we will focus on  consists in minimizing  $MT({\cal M})$. Note that in the context of cloud-RAN networks, we consider $P=1ms$, $\theta=2.6ms$ and $T_{max}$ must be less or equal to $3ms$.
      %cette remarque doit être dans la partie expérimentale



  In this article, we works on a given routage, but we could imagine a problem, in which, considering a given graph $G = (V,A)$ and a period P, the question is to find, if it exists, a routage graph ${\cal R}_{\cal C}$, in which there is $(P,\tau)$-periodic affectation.
  
  
  \todo{Dire si on regle le probleme de trouver un bon routage dans un cas particulier après}
  
  
\section{Solving PRA}
  \label{sec:complexity}
  \subsection{NP-Hardness}

 In this section we assume that the size of a message $\tau$ is equal to one. 
 We will prove the hardness of PRA and PALL for this parameter, which implies the hardness of the general problems. 
Consider an instance of the problem PRA, i.e., a routage graph $\cal{R_{\cal C}}$ and a period $P$. \\
The {\bf conflict depth} of a route is the number of other routes which share an edge with it. 
The conflict depth of a routage graph  $\cal{R_{\cal C}}$ is the maximum of the conflict depth of the routes in $\cal{R_{\cal C}}$.\\
The {\bf load} of a routage graph is the maximal number of routes sharing the same arc.
It is clear that a $(P,1)$-periodic affectation must satisfy that $P$ is larger or equal to the load.


We give two alternate proofs that PRA is $\NP$-complete.
The first one works for conflict depth $2$ and is minimal in this regards since we later prove that for conflict depth one,
it is easy to solve PRA. The second one reduces the problem to graph coloring and implies inapproximability when one tries to minimize the parameter $P$. \\

 \begin{proposition}
Problem PRA is $\NP$-complete, when the routing is of conflict depth two.
\end{proposition}
 \begin{proof}
 The problem $PRA$ is in $\NP$ since given an offset for each route in an affectation, it is easy to check in linear time in the number of edges whether there are collisions.
 
  Let $H=(V,E)$ be a graph and let $d$ be its maximal degree. We consider the problem to determine whether $H$ is edge-colorable
  with $d$ or $d+1$ colors. The edge coloring problem is $\NP$-hard~\cite{holyer1981np} and we reduce it to PRA to prove its $\NP$-hardness. We define from $H$ an instance of PRA as follows. 
  For each $v$ in $V$, the graph $G$ has two vertices $v_1, v_2$, and for each $(u,v) \in E$,the graph G has two vertices $s_{u,v}, t_{u,v}$. Set an arbitrary orientation of the edge $(u,v)$, such that the following route is directed from $u$ to $v$.
  
%   The set $A$ of arcs of $G$ is: 
%   $$ \{(v_1,v_2) \mid v\in V\} \cup \{(u_2,v_1)\mid u \neq v \in V^2\} \cup \{(s_{u,v},u_1),(v_2,t_{u,v}) \mid (u,v) \in E \}. $$
  For each edge $(u,v) \in E$, there is a route $s_{u,v},u_1,u_2,v_1,v_2,t_{u,v}$ in ${\cal R}$.  
  All these arcs are of weight $0$. 
  The set of arcs of G is the union between all the arcs of the previous routes.
  The affectation ${\cal C}$ is the set of pair of vertices $(s_{u,v}, t_{u,v})$.
   
    
  Observe that the existence of a $d$-coloring of $H$ is equivalent to the existence of a $(d,1)$-periodic affectation
  of ${\cal R}_{\cal C}$. Indeed, a $d$-coloring of $H$ can be seen as a labeling of its edges by the integers
  in $\{0,\dots,d-1\}$ and we have a bijection between $d$-colorings of $H$ and offsets of the routes of ${\cal R}_{\cal C}$.
  By construction, the constraint of having no collision between the routes is equivalent to the fact that no two adjacent edges have
  the same color. Therefore we have reduced edge coloring to PRA which concludes the proof. 
 \end{proof}
 \todo{Faire un dessin d'illustration ?}
 
 Remark that we have used zero weight in the proof. If we ask the weights to be strictly positive, which makes sense in our model since
they represent the latency of physical links, it is easy to adapt the proof. We just have to set them so that in any route the delay at $u_1$ is equal to $d$ and thus equal to $0$ modulo $d$. We now lift this hardness result to the problem PALL.

\begin{corollary}
Problem PALL is $\NP$-complete for routing of conflict depth two.
\end{corollary}
\begin{proof}
 We consider $({\cal R}_{\cal C},P,\tau)$ an instance of $PRA$. We assume that no vertex appears both in the first and second position in a pair of ${\cal C}$. Remark that this condition is satisfied in the previous proof, which makes the problem $PRA$ restricted to this kind of instances $\NP$-complete. 
 Let us define $T_{max} = 2 \times \max_{r \in {\cal R}} \lambda(r) + P$. We consider ${\cal C}'$ and ${\cal R}'_{\cal C'}$ symmetrized versions of ${\cal C}$ and  ${\cal R}_{\cal C}$ where for every route there is a symmetric route with new arcs and the same weights.
 The instance $({\cal R'}_{\cal C'},P,\tau,T_{max})$ is in PALL if and only if $({\cal R}_{\cal C},P,\tau)	$
 is in $PRA$. Indeed the waiting time of each route is by definition less than $P$ and thus the maximal process time is always less than $T_{max}$. Moreover a $(P,\tau)$-affectation of ${\cal R}_{\cal C}$ can be extended into a $(P,\tau)$-affectation of ${\cal R'}_{\cal C'}$ in the following way. For each route $r_{u,v}$, the time at which the message arrives is $t(v,r_{u,v})$, then we choose as offset for $r_{v,u}$, $-t(v,r_{u,v}) \mod P$. The symmetry ensures that each new route $r_{v,u}$ in ${\cal R'}_{\cal C'}$ uses the same times slot as $r_{u,v}$ and thus avoid collisions.
\end{proof}

Let MIN-PRA be the problem, given a routage graph and an assignment, to find the minimal period $P$ such that there is a $P$-periodic affectation. 

\begin{theorem}
 The problem MIN-PRA cannot be approximated in polynomial time within a factor $n^{1-o(1)}$, with $n$ the number of routes, unless $\P = \NP$ even when the load is two.
\end{theorem}

\begin{proof}
 We reduce graph coloring to PRA. Let $H$ be a graph instance of the $k$-coloring problem. 
 We define ${\cal R}$ in the following way: for each vertex $v$ in $H$, there is a route $r_v$ in ${\cal R}$.
 Two routes $r_v$ and $r_u$ share an arc if and only if $(u,v)$ is an edge in $H$; this arc is the only one shared by these two routes.   
 All arcs are of delay $0$. 
 
 Observe that the existence of a $k$-coloring of $H$ is equivalent to the existence of a $(k,1)$-periodic affectation in $G$, 
 by converting an offset of a route into a color of a vertex and reciprocally. Therefore if we can approximate the minimum value of $P$ within some factor, we could approximate the minimal number of colors needed to color a graph within the same factor. The proof follows from the hardness of approximability of finding a minimal coloring~\cite{zuckerman2006linear}.
\end{proof}


In particular, this reduction shows that even with small maximal load, the 
minimal period can be large.

    \scalebox{0.5}{

    \begin{tikzpicture}

    \tikzset{
      LabelStyle/.style = { rectangle, rounded corners, draw,
			  font = \bfseries },
      EdgeStyle/.append style = {->} }
      \SetGraphUnit{5}
      
      
      \node[draw,circle] (s3) at (4, 2) {$s_2$}; 
      \node[draw,circle] (s2) at (0, 4) {$s_1$}; 
      \node[draw,circle] (s1) at (0, 6) {$s_0$}; 

      \node[draw,circle] (t3) at (12, 3) {$t_2$}; 
      \node[draw,circle] (t2) at (14, 4) {$t_1$}; 
      \node[draw,circle] (t1) at (10, 2) {$t_0$}; 
      

      \tikzstyle{VertexStyle}=[shape = circle, draw, minimum size = 20pt]
	\tikzset{
      VertexStyle/.append style = {blue} }
	\Vertex[x=-8,y=3]{1}
	      \tikzset{
      VertexStyle/.append style = {green} }
	  \Vertex[x=-7,y=5]{2}

	    \tikzset{
      VertexStyle/.append style = {red} }
	  \Vertex[x=-6,y=4]{3}
		\tikzset{
      VertexStyle/.append style = {black} }
      
      
      \SetVertexNoLabel
      \Vertex[x=2,y=5]{A}
      \Vertex[x=4,y=5]{B}
      \Vertex[x=10,y=5]{C}
      \Vertex[x=12,y=5]{D}
      \Vertex[x=6,y=3]{E}
      \Vertex[x=8,y=3]{F}
      \tikzset{
      EdgeStyle/.append style = {green} }
      \Edge(s2)(A)
      \Edge(A)(B)
      \Edge(B)(C)
      \Edge(C)(D)
      \Edge(D)(t2)

      
      \tikzset{
      EdgeStyle/.append style = {red} }
      \Edge(s3)(E)
      \Edge(E)(F)
      \Edge(F)(t3) 
	\tikzset{
      EdgeStyle/.append style = {blue} }
      \Edge(s1)(A)
      \Edge(A)(B)
      \Edge(B)(E)
      \Edge(E)(F)
      \Edge(F)(t1)
      
	\tikzset{
      EdgeStyle/.append style = {black,-} }

      \Edge(1)(2)
      \Edge(1)(3)
    \node (1) at (-3,4){\Huge $\rightarrow$};
    
    \node (2) at (-7,0){\Huge H};
    \node (3) at (10,0){\Huge G};
    \end{tikzpicture}


    }
    
    
  \subsection{Tractable cases of PRA}
    
    In this section, we present a few polynomial cases, in particular when the conflict depth is one.
    
    
    The problem PALL seems to be hard to solve, even for very simple classes of graphs, as seen in the next section.
    
\section{The Star Topology}
  
   
    
      In this section, we consider graphs with a very simple topology that we call the {\bf star topology}. 
      First, for each arc $(u,v)$, there is also an arc $(v,u)$ with the same weight.
      Moreover, there is a special arc, the central arc, which is shared by all routes.
      All routes consist from an arc from its source to the central source node, denoted by {\bf $c_s$},
      then the central arc to {\bf $c_t$}, the central target node, and an arc to its target. In addition to those central nodes, there are two sets of vertices, $S=\{s_0,...,s_{n-1}\}$ and $T=\{t_0,...,t_{n-1}\}$, of cardinality $n$ and ${\cal C}$ a symmetric assignment from $S$ to $T$. 
      The routes are the directed paths of the form $s_i,c_s,c_t,t_i$ and $t_i,c_t,c_s,s_i$. 
      
      
       \begin{center}
	 
\begin{tikzpicture}

\tikzset{
  LabelStyle/.style = { rectangle, rounded corners, draw,
                       font = \bfseries },
  EdgeStyle/.append style = {->} }

  \SetGraphUnit{5}
  
  \node[draw,circle] (s3) at (0, 0) {$s_2$}; 
  \node[draw,circle] (s2) at (0, 2) {$s_1$}; 
  \node[draw,circle] (s1) at (0, 4) {$s_0$}; 

  \node[draw,circle] (t3) at (8, 0) {$t_2$}; 
  \node[draw,circle] (t2) at (8, 2) {$t_1$}; 
  \node[draw,circle] (t1) at (8, 4) {$t_0$}; 
  

  \node[draw,circle] (cs) at (2, 2) {$c_s$}; 
  \node[draw,circle] (ct) at (6, 2) {$c_t$}; 

  
  \Edge(s1)(cs)
  \Edge(s2)(cs)
  \Edge(s3)(cs)
  
  \Edge(ct)(t1)
  \Edge(ct)(t2)
  \Edge(ct)(t3)
  
  \Edge(cs)(ct)

  
\end{tikzpicture}

  \end{center}
	
      We assume the weight of the central arc to be $0$ since it appears in every route,
      its value does not matter when considering affectations.\\
      Collisions between messages can only appear at node $c_s$ on the way forward and at node $c_t$ on the way back.
      Thus, we only have to check if there is no collisions in a period at those two points.
      We consider two periods P at these vertices, the the {\bf forward period} at $c_s$, and the {\bf backward period} at $c_t$. A message issued by the source $s_1$ at time $m_{s_1}$ will reach $c_s$ at time $m_{s_1} + t(c_s,r_{s_1}) \mod P$ in the forward period, and  $c_t$ at time $m_{t_1} + t(c_t,r_{t_1})\mod P$ in the backward period.
      A $(P,\tau)$-periodic affectation consist in choosing for all $i < n$, $m_i$ and $m_{{\cal C}(s_i)}$ such that, for any couple $(j,k)$,
      we have $[t(c_s,r_{s_{j}})] \cap [t(c_s,r_{s_k})] = \emptyset$ and $[t(c_t,r_{t_j})] \cap [t(c_t,r_{t_k})] = \emptyset$.

      

  \subsection{Solving PALL without waiting times}
  
  In this subsection, we deal with a simpler version of the problem PALL.
  We ask for a $(P,\tau)$-periodic affectation {\bf with all waiting times equal to $0$} and we call this restricted problem  ??????????????? . 
  In that case $MT({\cal M})$ is equal to twice the delay of the longer route, thus $T_{max}$ is not relevant anymore. 
  Since $w_i=0$, choosing $m_i$, the offset of the route from $s_i$ to $t_i$, also sets the offset of the route from $t_i$ to $s_i$ to $m_i + \lambda(r_i) \mod P$.
  Remark that we can assume that the weight of the arcs from $s_i$ to $c_s$ are all equal to $0$, since we can change 
  all $m_i$ into $m_i - t(c_s,r_i) \mod P$ and obtain the same affectation.
  
  \todo{Attention cette simplification n'est pas assez explicite.}
    
  
    \subsubsection{Shortest-longest policy}
    

    
    We present a simple policy, which works when the period is large with regards to the delay of the routes.
    The message are sent in order from the shortest route to the longest route, without any gap between two messages in the forward period.
    In other words, we assume that the route $r_i$ are sorted by increasing $\lambda(r_i)$ and we set $m_{s_i} = i\tau$.
    We call this algorithm {\bf Shortest-Longest}.
      
     By definition, there are no collision in the forward period and if the period is long enough, 
     it is easy to see that the order of the messages are the same as in the forward period and that no collision can occur. 
      
      
      \begin{proposition}
       The algorithm Shortest-Longest solves ??????????? if $n\tau + 2(\lambda(r_{s_{n-1}}) - \lambda(r_{s_0})) \leq P$.
      \end{proposition}
      \begin{proof}
       Since $m_{s_i} = i\tau$, $[t(c_s,r_{s_i})] = \{i\tau,\dots, (i+1)\tau -1\}$ and there are no collision on the forward period.
       We assume that $\lambda(r_{s_0}) = 0$, by removing $\lambda(r_{s_0})$ to every route, it does not change their order
       or the result of this algorithm.
      
      
      We have  $[t(c_s,r_{t_i})] = \{2 \lambda(r_{s_i}) + i\tau, \dots,  2 \lambda(r_{s_i}) + (i+1)\tau -1\}$ since $2 \lambda(r_{s_{n-1 }}) + n\tau \leq P$.
       Since $ \lambda(r_{s_i}) \leq  \lambda(r_{s_{i+1}})$ by construction, we have  $2 \lambda(r_{s_i}) + (i+1)\tau -1 < 2 \lambda(r_{s_{i+1}}) + (i+1)\tau$
       which proves that there are no collision on the backward period. 
      \end{proof}

      
      If the period is slightly smaller that the bound, a collision will occur on the route in the backward period, making 
      this policy not useful even as a heuristic for longer routes. 
      
%       
% The message using the shortest route is sent before the others, therefore on the backward period it cannot conflict 
% 
% comes back to the central node before the following ones.
% Then, the second message is sent before the others, and also will be back before the third etc... 
% Because the message $i$ is sent $\tau$ slots after the message $i-1$ ($m_{s_i} = m_{s_{i-1}} + \tau$), it comes back after the end of the message $i-1$: $m_{s_{i-1}}+ \tau + 2.\lambda(r_{s_{i-1}}) \le m_{s_i} + 2.\lambda(r_{s_i})$ because of $\lambda(r_{s_i}) \ge \lambda(r_{s_{i-1}})$.
% 
%       Because of $m_{s_i} = \tau.i$ in the forward period, there is no collisions.
%       To ensure that there is no collisions in the backward period, we must ensure that the last message ends before the end of the period P. We have to find the minimum period P such that the last message have totally came back before P slots after the first message.
%       
%       The this policy ensure us a period of $$P = \tau * n + 2(\lambda(r_{s_{n-1}}) - \lambda(r_{s_0}))$$ if routes $\{r_0,...,r_{s_{n-1}}\}$ are ordered
% from the shortest to the longest. 
% 
% We have to calculate the time taken by the last message to reach $c_t$. $2.\lambda(r_{s_0})$ is the first slot in which the first message is coming back in the backward period,
% and 2$\lambda(r_{s_{n-1}}) + n . \tau $ is the time at which the last message has totally passed the switch.
% Therefore, the period only depends of the difference between the longest and the shortest route: the larger this value is, the larger
% the period is.
%    
   
    \subsubsection{Greedy Algorithm}
    
    We propose a greedy algorithm to build a $(P,\tau)$-periodic affectation, which provably works when
    the period is large enough with regards to the number of routes and size of messages. In other words, 
    we can always find a solution when the network is far from saturated. 
    
    \begin{proposition}
    There is an algorithm, which finds a $(P,\tau)$-periodic affectation in time $O(n^2)$ when $P \geq 3n\tau$,
    where $n$ is the number of routes.
    \end{proposition}
    \begin{proof}
     We consider the forward period and cut it into consecutive macro slots of $\tau$ time slots. The algorithm works by chosing an offset for each route in the following way: try all offests which put the message in a yet not used macro slot in the forward
     period. An offset also fixes the position of the message in the backwward period, chose the first one which does not create a collision. We now prove that this algorithm always find an offset for all routes when $P \geq 3n\tau$.
     
     Assume we are choosing the offset of the route $r_{k+1}$, we have  at least $P - k \geq 3n - k$ free macro-slots, since $P \geq 3n\tau$. Each of these $3n - k$ possible offset values translates into $3n - k$ positions of messages in the backward period. All these positions are separated by at least $\tau$ slots. There are already $k$ messages of size $\tau$ in the backward period. One such message can intersect at most $2$ potential positions since they are disjoint intervals. Therefore  amongst the possible $3n - k$ positions, there are  $3n - k -2k$ which are without collision. Since $k < n$, one of the choice is without collision, which proves that the algorithm terminates and find a  $(P,\tau)$-periodic affectation. 
     
     This algorithm works with a complexity $O(n^2)$, since for the $k^{\text{th}}$ route we have to try at most $2k$ offsets before finding a correct one. We can test the $2k$ offsets of the backward period in time $O(k)$ by maintaining an ordered list of the intervals used by already set routes.
     \end{proof}
     
      \begin{center}
      \includegraphics[scale=0.3]{ex3nt.png}
      \end{center}
	\begin{algorithm}[H]
	\caption{Greedy affectation}
	\begin{algorithmic}
	\REQUIRE ${\cal R}_{\cal C}$, period $P$
	\ENSURE A P-periodic affectation in p $\leq P$, or FAILURE
	\STATE $P1[P/\tau]$ macro slots of size $\tau$ in forward period.
	\STATE $P2[P]$ slots backward period.
	\FORALL{source $s_i$ in S }

	\FORALL{macro slot j in P1}

	\IF{$P1[j]$ is free AND the corresponding slots in P2 are free}

	
	\STATE $m_{s_i} \leftarrow j.\tau$
	\ENDIF


	\IF{No intervals are found for $s_i$}
	\STATE return FAILURE
	\ENDIF
	\ENDFOR

	\ENDFOR

	\end{algorithmic}
	\end{algorithm}
	
This algorithm, contrarily to the previous one, may work well, even when the condition $P \geq 3n\tau$ is not true.
In fact, experimental data in Subsection~\ref{} suggest that the algorithm works well as soon as $P \geq ????? \tau$.
	
	\subsubsection{Exhaustive search}
% 	\begin{algorithm}[H]
% 	\caption{Exhaustive Generation}  
% 	\begin{algorithmic}
% 	\REQUIRE A routage graph ${\cal R}_{\cal C}$, period $P$, packet size $\tau$
% 	\ENSURE $(P,\tau)$-periodic affectation of ${\cal R}_{\cal C}$
% 	\STATE Forward-budget $\leftarrow$ $P$ - n * $\tau$
% 	\STATE Backward-budget $\leftarrow$ $P$ - n * $\tau$
% 	\STATE Free-Intervals $\leftarrow$ list of free intervals in the backward period, init to $[0;P[$
% 	\FORALL{source $s_i$ in S}
% 	\FORALL{j in Free-Intervals }
% 	\IF{Message of the route $r_{s_i}$ does not collides with scheduled routes}
% 	\STATE $m_{s_i} \leftarrow $ the first slot of Free-Intervals[j]
% 	\STATE Split the Free-Intervals considering the new packet
% 	\STATE Forward-budget $\leftarrow$ Forward-budget - {\em lost size}
% 	\STATE Backward-budget $\leftarrow$ Backward-budget - {\em lost size}
% 	\STATE call Exhaustive Generation on remaining routes
% 	\ENDIF
% 	\ENDFOR
% 	\ENDFOR
% 
% 
%       \end{algorithmic}
%       \end{algorithm}

% 	    
      We now present an exhaustive search algorithm, which tries to set the offsets in all possible ways until it has found
      a $(P,\tau)$-periodic affectation. The algorithm is a depth-first traversal of a tree whose leaves are the $(P,\tau)$-periodic
      affectations or failures and the nodes are partial solutions. A partial solution $S$ is a choice of a starting time for a subset of the routes such that none of these routes collide in the forward or backward period. For simplicity we will also denote by $S$ the set of routes whose offsets are fixed by $S$. A partial solution $S'$ extends $S$ if $S' = S \cup \{r'\}$ and for all $r \in S$, $m_r + \tau \leq m_{r'}$, that is the route $r'$ comes after all routes in $S$ in the forward period. In the tree, the children of a partial solutions are all partial solutions which extend it. Therefore a node corresponding to $k$ fixed routes can have as many as $(n-k)P$ children. Since the tree is of depth $n$, we can have as many as $n!P^n$ elements and while $n$ is often small, $P$ may be large.  Therefore we have to find cuts in the tree to avoid to explore it entirely and henceforth make the algorithm practical. We propose the three following ones, the first two being useful when the period is small with regards to the number of routes:
      
      
      \todo{       Trouver un meilleur vocabulaire, peut-être avec des intervalles triés pour représenter les solutions partielles}
      
      \begin{enumerate}
       \item We maintain a counter $c_f$ which counts the number of routes which can be placed in the forward
       period. If at some point this number is less than the number of routes which are not in the partial solution,
       it is a failure and the algorithm backtracks. At the beginning of the algorithm $c_f = P / \tau$.
       Then when a route is fixed at some offset $m_r$, larger than all previous offsets, then $c_f = (P - m_r) / \tau $. 
       
       
       \item We maintain a counter $c_b$ which counts the number of routes which can be placed in the backward
       period. If at some point this number is less than the number of routes which are not in the partial solution,
       it is a failure and the algorithm backtracks. At the beginning of the algorithm $c_f = P / \tau$.
       Consider a partial solution with $k$ routes and denote by $a_i$ their offset in the backward period.
       The $a_i$ are in increasing order and without loss of generality we assume that $a_1 = 0$. Remark that the number of routes which can be placed in the interval of free slots $\{a_i+\tau, a_{i+1}-1\}$
       is $(a_{i+1} -a_i) / \tau) -1 $. Therefore the total number of routes which can be placed in the backward period is $\displaystyle{\left( \sum_{i=1}^{k-1} (a_{i+1} -a_i)/\tau - 1 \right)} + (P - a_k) / \tau $.
       The counter $c_b$ can be maintained in constant time since each time a route is added, an interval is split into two and we can 
       use these two new intervals only to update its value.
       
%        In the forward windows, each message is placed after the previous one, that is $m_{s_i} > m_{s_j}$ (here, $s_i$ is the source placed before $s_j$ by the algorithm). Each time a new message is scheduled, there is some possible lost slots between $m_{s_i}+\tau$ and $ m_{s_j}$. We hold a counter of remaining slots and decrease it from the number of lost slots each time a new message is scheduled. Thus, if the number of the remaining slots in the forward period is lower than the number of slots needed to put the remaining messages, we can consider that the actual partial solution is not good.
%        \item  Each time we add a new message in the backward period, we cut a free interval in two new smaller free intervals, plus the scheduled message. Each free intervals has a number of macro slots (ex: 2,6). If the sum of all the integer parts of the macro slots is lower than the number of remaining messages to schedule, the actual partial solution is not good.
       \item 
       Let $S_1$ and $S_2$ be two partial solutions with the same subset of fixed routes, but different offsets.
       A sequence of extensions of a partial solution $S$ is a sequence of pair of route and offset, which define a path from $S$ in the tree. We say that $S_1$ dominates $S_2$, if any sequences of extensions of $S_2$, is a sequence of extensions of $S_1$.
       Then if there is a solution in $S_2$, there must be also one in $S_1$, therefore if we detect that some node is dominated in the tree we can backtrak when we encounter it. 
       
       %Meilleure explication notion de slots utilisables. Si une solution partielle a strictement moins de slots utilisables (vu en tant qu'ensemble) qu'une autre avec les mêmes routes alors elle est dominée
       
       Consider a partial solution $S$ which we extend into $S' = S \cup \{ r \}$ such that the offset of 
       $r$ is the smallest possible, denoted by $m$.
       Say that the offset of $r$ in the backward period is $m+ \lambda$ and that the end of the message before $m + \lambda$ in the backward period is $a$. Then all extensions of $S$ into $S'' = S \cup \{ r \}$ with $ m < m_r < a + \tau - \lambda$.
       are dominated by $S'$. Indeed, $S''$ have striclty less empty slots in the forward period and in the backward period, there are only two intervals ... 
       
       \todo{       Mettre un dessin !!!!  Dire comment la coupe 3 interragit bien avec la 1, car elle force $m_i$ à croitre vite, ce qui
       permet d'appliquer rapidement la coupe}
           
             \end{enumerate}
      
      


    \subsubsection{Results}
      The following performance evaluation results compares the previous algorithms. Since we try to find a linear time algorithm for the problem PALL, Exhaustive Generation is not a good solution. However, Greedy 3NT and Shortest-Longest are some greedy heuristics and gives us a linear complexity. We tried to determine which algorithm gives a solution with the minimal period.
      In a first time, we will have a look at the results with the parameters corresponding to Cloud-RAN context.
      \paragraph{Short routes}
      To correspond with the C-RAN applications, we made some simulations on graphs in which $\lambda(r_{s_i}) < 2100$ slots, that is, at the most, 5 km between the RRH and its BBU. The messages size $\tau$ is to 2500 slots, that is, approximately 1.228 Gbps of data for each route. The size of a slot is given by the time taken to send 64 bytes on the network, in which the links has 10Gbps throughput.
      
      For each algorithm, we made a linear research of the minimal period for which, there is a solution on the given instance. The following figure shows us the average periods on 1000 graphs, for a growing number of routes.
      The results of the Exhaustive generation can be considered as a lower bound, indeed, for a given period, this algorithm finds the solution, if it exists.
      As an information, we drew the $\tau.n$ (i.e. the size taken by the messages in the period) and the $2.(\tau.n) $ lines.
      
      \begin{center}
      \includegraphics[scale=0.4]{periode_petite.pdf}
      \end{center}
     

      
     
      With those parameters, we can observe that the average period of the Shortest-Longest algorithm, which is determined by the difference between the longest and the shortest route, is always equal to the Exhaustive generation, that is, the lower bound.
      The next results is to theoretically prove that, with those parameters, the Shortest-Longest algorithm gives optimal solutions, like this experimental study suggests it does. 
      About the Greedy 3NT Algorithm, with those parameters, it always gives us bigger periods than the Shortest longest. 
      We can also observe that, for any algorithm, the average minimal periods increases linearly with the number of routes. Thus, the following experiences are made on a fixed number of routes : 8.
      
      Then, we looked at the evolution of the minimal period required with the different algorithm if we significantly increase the size of the route. The following figure shows us the success rate of the algorithms, for 8 routes of size between 0 and 60000 slots, according to the period.
      
       \begin{center}
      \includegraphics[scale=0.4]{echec_longues.pdf}
      \end{center}
     
      
      As we can see, the Shortest longest has a very low success rate, because of the distribution of the size of the routes is now broader, so is the required period.
      Whereas, the Geedy 3NT gives us solutions with much lower period than Shortest Longest.
      Because of it's polynomial complexity, the Exhaustive generation can freeze the simulation when the solution is not easy to find. Thus, we let it stop after a defined number of calculation. 
      The Exhaustive Generation curve gives us the solution when the algorithm has found a solution, and the Upper bound gives us the number of found solutions plus the number of time the algorithm stopped. The real Upper bound is probably between those two curves.
      
      So, those experiences shows us that for real topologies with small routes, the Shortest-Longest algorithm finds some affectations with small Periods, but, the longer the routes are, the better it is to use the Greedy policy to find a solution without waiting times.\\
      Nevertheless, if we want to consider networks, the period is fixed. As we just saw, if the load increases, the needed period increases too, and it is not possible anymore to find a solution without waiting times with a small period. The solution is to allow some messages to wait on target nodes, as described in the next section.
      
   \subsection{Allowing waiting times}
   
     \subsubsection{Intro}
	  We now consider waiting times. The weights on links from sources to $c_s$ are now relevant because the goal is to minimize $MT({\cal M})$, with ${\cal M}$ the $(P-\tau)-$periodic affectation of ${\cal R_{\cal C}}$.
	  To build such a $(P-\tau)-$periodic affectation of ${\cal R_{\cal C}}$, we must choose the offsets $m_{s_i}$ and $m_{t_i}$, such that there is no $PT(s)$ greater than a given $T_{max}$.
	  As a reminder, $ PT(s)=\lambda(r_s)+ w_s+\lambda(r_{t_i})$.
     \subsubsection{LSG}
     

     \todo{Il faut faire une présentation modulaire avec d'un coté choix de de départ des messages, ->LS, ->SL, ->RANDOM
     puis choix de retour, Greedy et Optimal. Ensuite on montre que dans le cas simple de toutes les arêtes de départ à la même valeur,
     LSG est optimal (dire que c'est un cas raisonnable). Éventuellement deux valeurs différentes serait raisonnable mais je n'ai pas trouvé de bons algos.
     Ensuite il faut expliquer proprement greedy et Simons (sans donner tous les détails pour Simons) et expliquer les limitations -> pas de gestion de la période pour Simons.
     On peut gérer la période pour Simons en bruteforce sur les routes. Il faut que j'écrive mes algos FPTs en le nombre de routes même si on ne les implémente pas.}
     
To find a solution with waiting times, the following heuristic is suggested:

On the forward period, the messages are scheduled so that they are following each others, from the one using the longest route, to the one using the shortest route. Thus, we set the $m_{s_i}$ of the routes such that  $t(c_s,r_{s_i}) = \tau.i$, if the routes $r_i$ are ordered from the longest to the shortest.

On $c_t$, the policy is the following one, after setting the clock to 0:
\begin{enumerate}
 \item To be eligible, a job needs to be able to come back on the switch at the current clock (if clock = 0, take the first message able to come back).
 \item Between the eligible jobs, schedule first the one which has the longest route and gives it the offset time $m_{\cal C(s_i)} = clock$.
 \item Update the clock at the time in which the scheduled task is over: $$clock = clock + message\ length$$.
\end{enumerate}

\begin{algorithm}[H]
\caption{LSG}
\begin{algorithmic}
\REQUIRE routage graph ${\cal R_{\cal C}}$, period $P$, packet size $\tau$
\ENSURE $(P-\tau)-$periodic affectation of ${\cal R_{\cal C}}$
\STATE clock $\leftarrow$ 0
\FORALL{route i in $r_{s_i}$ from the longest to the shortest }
\STATE  $m_{s_i} \leftarrow$ clock
\STATE clock $\leftarrow$ clock + $\tau$
\ENDFOR
\STATE clock $\leftarrow$ 0
\STATE take i such that $r_{\cal C(s_i)}$ is the first route to come back in sources switch
\STATE $m_{\cal C(s_i)} \leftarrow $ clock;
\STATE clock $\leftarrow$ $t(c_t,r_{\cal C(s_i)})$ + $\tau$
\WHILE{there is a route which has not been scheduled}
\STATE take i such that $r_{\cal C(s_i)}$ is the eligible route.
\STATE $m_{\cal C(s_i)} \leftarrow $ clock - $t(c_t,r_{\cal C(s_i)})$;
\STATE clock $\leftarrow$ clock + $\tau$

\ENDWHILE

\end{algorithmic}
\end{algorithm}

	\paragraph{Algorithm}
	\paragraph{Analysis}
	
One of the closest approach to real networks is the case in which all the weight on the arcs going from $c_t$ to targets are the, this algorithm gives an optimal solution. Indeed, all the same weight can be simplified by 0, thus the scheduling in the forward and backward period is the same, that is, all message following each others, so the period is minimal : $n.\tau$, where $n$ is the number of couples $(s,{\cal C}(s))$. Furthermore, all the waiting times are set to 0 i.e. $w_i = 0,\forall i \in n$, thus, $MT({\cal M})$ is equal to twice the longer delay of the routes, that is not alterable.

Another case of this topology is the case in which all the weight on the arcs between $c_s$ and the sources are the same.
In this case, the algorithm gives optimal solutions too:\\

We consider only the delay between $c_t$ and the targets, that are $\lambda(r_{s})$. Order the routes such that $\lambda(r_{s_i}) > \lambda(r_{s_j}), i,j \in n, i<j$, i.e. the route 1 is the longest one, and the route $n$ is the shortest.
The messages are sent in the forward period from 0 to $n-1$, that is $m_{s_i} = \tau * n$.

The first message has totally reach the backward period at time $2.\lambda(r_{s_0})+\tau$. The process time of the first message is so $PT(s_0) = 2.\lambda(r_{s_0}) + \tau$.
The second message is eligible in the backward period at time $\tau + 2.\lambda(r_{s_1})$. Thus, the waiting time of the second route is $w_{s_1} = 2.\lambda(r_{s_0})+\tau - (\tau + 2.\lambda(r_{s_1})) = 2.(\lambda(r_{s_0}) - \lambda(r_{s_1}))$. Thus $PT(s_1) = 2.\lambda(r_{s_1}) + 2.(\lambda(r_{s_0}) - \lambda(r_{s_1})) +\tau = 2.\lambda(r_{s_0}) + \tau = PT(s_0)$.
By induction, $PT(s_i) = PT(s_0), \forall i \in n$. 
Consequently, for this case, the heuristic is optimal, because the longest route has no waiting time all the other routes will take exactly the same time, thus, $MT(M) = PT(s_0) = 2.\lambda(r_{s_0}) + \tau$, which is not alterable

     \subsubsection{Results}
	 \paragraph{Random}
	 \paragraph{Distributions}
   
\section{Conclusion}


Open questions. Can we improve the results if:
\begin{itemize}
 \item The routes are smaller than the size of a message. 
\item The routes are smaller than the period.
\item The largest difference between two routes is smallest than one of these parameters
\end{itemize}

 On a general graph:
 
\begin{itemize}
\item The routing is coherent
 \item The graph is symmetric
\end{itemize}


\bibliographystyle{ieeetr}
\bibliography{Sources.bib}

\end{document}
